<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é›»æ°—å›è·¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ 2026 (Physics Perfect Edition)</title>
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
    <script defer
      src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
      crossorigin="anonymous"
      onload="try{
          renderMathInElement(document.body, {
              delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false},
                  {left: '\\(', right: '\\)', display: false},
                  {left: '\\[', right: '\\]', display: true}
              ],
              throwOnError: false
          });
      } catch(e) { console.error(e); }"></script>

    <style>
        :root {
            --primary-color: #2c3e50; --accent-color: #3498db; --bg-color: #f4f4f9;
            --text-color: #333; --graph-bg: #fff; --success-color: #27ae60; --danger-color: #e74c3c; --warning-color: #f39c12;
        }
        body { font-family: 'Helvetica Neue', Arial, sans-serif; margin: 0; background: var(--bg-color); color: var(--text-color); display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        .tab-nav { background: #fff; padding: 0 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); z-index: 20; display: flex; align-items: center; height: 50px; flex-shrink: 0; }
        .tab-btn { background: none; border: none; padding: 15px 25px; font-size: 16px; font-weight: bold; color: #7f8c8d; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.3s; }
        .tab-btn:hover { color: var(--accent-color); }
        .tab-btn.active { color: var(--primary-color); border-bottom: 3px solid var(--accent-color); }
        .app-title { margin-left: auto; font-size: 14px; color: #999; font-weight: normal; }
        .content-area { flex-grow: 1; position: relative; overflow: hidden; }
        .tab-pane { display: none; width: 100%; height: 100%; overflow-y: auto; }
        .tab-pane.active { display: flex; flex-direction: column; }
        #theory-pane { background: #fff; padding: 40px; box-sizing: border-box; max-width: 900px; margin: 0 auto; }
        h1 { border-bottom: 2px solid var(--accent-color); padding-bottom: 10px; color: var(--primary-color); }
        h2 { margin-top: 40px; border-left: 5px solid var(--accent-color); padding-left: 10px; color: var(--primary-color); background: #f9f9f9; padding: 10px; }
        h3 { margin-top: 25px; color: #555; }
        .box { background: #eef7fb; border: 1px solid #cceeff; padding: 15px; border-radius: 5px; margin: 15px 0; }
        #simulation-pane { flex-direction: row; height: 100%; overflow: hidden; }
        #sim-sidebar { width: 280px; background: #2c3e50; color: #ecf0f1; display: flex; flex-direction: column; padding: 15px; box-shadow: 2px 0 10px rgba(0,0,0,0.3); z-index: 10; overflow-y: auto; flex-shrink: 0; }
        #sim-sidebar h2 { border-bottom: 1px solid #7f8c8d; padding-bottom: 8px; color: #bdc3c7; font-size: 14px; text-transform: uppercase; margin-bottom: 15px; }
        .btn-group { display: flex; flex-direction: column; gap: 8px; margin-bottom: 20px; }
        .sim-btn { background: #34495e; color: #ecf0f1; border: 1px solid #465c71; padding: 10px 15px; cursor: pointer; text-align: left; border-radius: 6px; transition: all 0.2s; display: flex; align-items: center; font-size: 14px; }
        .sim-btn:hover { background: #465c71; transform: translateX(2px); }
        .sim-btn.active { background: #3498db; border-color: #2980b9; font-weight: bold; }
        .icon { width: 24px; text-align: center; margin-right: 12px; font-weight: bold; font-size: 16px; }
        .control-panel { display: flex; gap: 5px; margin-bottom: 10px; }
        .ctrl-btn { flex: 1; padding: 8px 0; border: none; border-radius: 4px; color: white; font-weight: bold; cursor: pointer; font-size: 13px; display: flex; justify-content: center; align-items: center; }
        .btn-start { background-color: var(--success-color); } .btn-stop { background-color: var(--danger-color); } .btn-reset { background-color: var(--warning-color); }
        .btn-toggle-all { width: 100%; padding: 8px 0; background-color: #8e44ad; color: white; border:none; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 13px; margin-bottom: 15px; }
        #properties { margin-bottom: 20px; background: #3e5062; padding: 15px; border-radius: 8px; }
        .prop-row { display: flex; justify-content: space-between; margin-bottom: 8px; align-items: center; font-size: 13px; }
        .prop-row input[type="number"] { width: 70px; padding: 4px; border-radius: 4px; border: none; font-weight: bold; color: #333; }
        .monitor-val { font-family: 'Consolas', monospace; color: #2ecc71; font-weight: bold; font-size: 15px; }
        #main-view { flex-grow: 1; display: flex; flex-direction: column; position: relative; background: #fff; overflow: hidden; }
        #canvas-wrapper { flex-grow: 1; position: relative; overflow: hidden; border-bottom: 1px solid #ccc; }
        #circuitCanvas { display: block; width: 100%; height: 100%; }
        #canvas-wrapper::before { content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: radial-gradient(#d0d0d0 1px, transparent 1px); background-size: 20px 20px; pointer-events: none; opacity: 0.5; }
        #graph-wrapper { height: 220px; background: var(--graph-bg); border-top: 1px solid #ddd; position: relative; padding: 5px; box-sizing: border-box; flex-shrink: 0; display: flex; flex-direction: column; }
        #graphCanvas { width: 100%; height: 100%; display: block; }
        .sim-info { position: absolute; top: 15px; right: 15px; background: rgba(255,255,255,0.95); padding: 15px; border: 1px solid #ddd; border-left: 4px solid #3498db; border-radius: 4px; pointer-events: none; font-size: 13px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); width: 280px; color: #333; }
        .status-badge { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: bold; color: white; margin-bottom: 5px; }
        .status-running { background: var(--success-color); } .status-stopped { background: var(--danger-color); }
    </style>
</head>
<body>

<div class="tab-nav">
    <button class="tab-btn active" onclick="switchTab('theory')">åŸºç¤çŸ¥è­˜</button>
    <button class="tab-btn" onclick="switchTab('simulation')">ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</button>
    <div class="app-title">é›»æ°—å›è·¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ 2026 (Physics Perfect Edition)</div>
</div>

<div class="content-area">
    <div id="theory-pane" class="tab-pane active">
        <div class="theory-container">
            <h1>é›»æ°—å›è·¯ç†è«–ã®åŸºç¤ (Fundamental Circuit Theory)</h1>
            <p>æœ¬ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€å¤å…¸çš„ãªã‚ªãƒ¼ãƒ ã®æ³•å‰‡ã‹ã‚‰å§‹ã¾ã‚Šã€å¾®åˆ†æ–¹ç¨‹å¼ã«ã‚ˆã‚‹éæ¸¡ç¾è±¡ã®è§£æã€ãã—ã¦è¤‡ç´ æ•°ã‚’ç”¨ã„ãŸäº¤æµç†è«–ï¼ˆãƒ•ã‚§ãƒ¼ã‚¶æ³•ï¼‰ã¾ã§ã‚’æ¦‚è¦³ã—ã¾ã™ã€‚</p>

            <h2>1. å›è·¯ç´ å­ã®å³å¯†ãªå®šç¾©</h2>
            <p>é›»åœ§ \(v(t)\) ã¨é›»æµ \(i(t)\) ã®é–¢ä¿‚ï¼ˆæ§‹æˆæ–¹ç¨‹å¼ï¼‰ã¯ã€æ™‚é–“å¾®åˆ†ãƒ»ç©åˆ†ã‚’ç”¨ã„ã¦ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¾ã™ã€‚</p>
            
            <h3>æŠµæŠ— (Resistor)</h3>
            <div class="box">
                $$v(t) = R i(t)$$
                <p>ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’ç†±ã¨ã—ã¦æ•£é€¸ã•ã›ã‚‹ç´ å­ã§ã™ã€‚</p>
            </div>

            <h3>ã‚³ã‚¤ãƒ« (Inductor)</h3>
            <div class="box">
                $$v(t) = L \frac{di(t)}{dt} \quad \Longleftrightarrow \quad i(t) = i(0) + \frac{1}{L} \int_{0}^{t} v(\tau) d\tau$$
                <p>é›»æµã®å¤‰åŒ–ã‚’å¦¨ã’ã‚‹æ–¹å‘ã«èµ·é›»åŠ›ã‚’ç”Ÿã˜ã¾ã™ï¼ˆãƒ•ã‚¡ãƒ©ãƒ‡ãƒ¼ã®é›»ç£èª˜å°ã®æ³•å‰‡ï¼‰ã€‚ç£æ°—ã‚¨ãƒãƒ«ã‚®ãƒ¼ \( W_L = \frac{1}{2}Li^2 \) ã‚’è“„ãˆã¾ã™ã€‚</p>
            </div>

            <h3>ã‚³ãƒ³ãƒ‡ãƒ³ã‚µãƒ¼ (Capacitor)</h3>
            <div class="box">
                $$i(t) = C \frac{dv(t)}{dt} \quad \Longleftrightarrow \quad v(t) = v(0) + \frac{1}{C} \int_{0}^{t} i(\tau) d\tau$$
                <p>é›»è· \(q(t) = Cv(t)\) ã‚’è“„ãˆã‚‹ç´ å­ã§ã™ã€‚é™é›»ã‚¨ãƒãƒ«ã‚®ãƒ¼ \( W_C = \frac{1}{2}Cv^2 \) ã‚’è“„ãˆã¾ã™ã€‚</p>
                <p><strong>ç‰©ç†çš„æ§‹é€ ã«ã‚ˆã‚‹å®¹é‡æ±ºå®š:</strong> å¹³è¡Œæ¿ã‚³ãƒ³ãƒ‡ãƒ³ã‚µãƒ¼ã®å ´åˆã€æ¥µæ¿é¢ç© \(S\)ã€æ¥µæ¿é–“è·é›¢ \(d\)ã€èª˜é›»ç‡ \(\varepsilon\) ã‚’ç”¨ã„ã¦ä»¥ä¸‹ã®ã‚ˆã†ã«è¡¨ã•ã‚Œã¾ã™ã€‚</p>
                $$C = \varepsilon \frac{S}{d}$$
            </div>

            <h2>2. ã‚­ãƒ«ãƒ’ãƒ›ãƒƒãƒ•ã®æ³•å‰‡ (Kirchhoff's Laws)</h2>
            <p>å›è·¯è§£æã®åŸºç¤ã¨ãªã‚‹2ã¤ã®ä¿å­˜å‰‡ã§ã™ã€‚</p>
            <ul>
                <li><strong>ç¬¬1æ³•å‰‡ï¼ˆKCL: é›»æµå‰‡ï¼‰</strong>ï¼šä»»æ„ã®æ¥ç¶šç‚¹ï¼ˆãƒãƒ¼ãƒ‰ï¼‰ã«ãŠã„ã¦ã€æµå…¥ã™ã‚‹é›»æµã®å’Œã¨æµå‡ºã™ã‚‹é›»æµã®å’Œã¯ç­‰ã—ã„ï¼ˆé›»è·ä¿å­˜å‰‡ï¼‰ã€‚
                $$\sum_{k} i_k(t) = 0$$
                </li>
                <li><strong>ç¬¬2æ³•å‰‡ï¼ˆKVL: é›»åœ§å‰‡ï¼‰</strong>ï¼šä»»æ„ã®é–‰å›è·¯ï¼ˆãƒ«ãƒ¼ãƒ—ï¼‰ã«ãŠã„ã¦ã€é›»åœ§é™ä¸‹ã®ç·å’Œã¯èµ·é›»åŠ›ã®ç·å’Œã«ç­‰ã—ã„ï¼ˆã‚¨ãƒãƒ«ã‚®ãƒ¼ä¿å­˜å‰‡ï¼‰ã€‚
                $$\sum_{k} v_k(t) = 0$$
                </li>
            </ul>

            <h2>3. éæ¸¡ç¾è±¡ (Transient Response)</h2>
            <p>ã‚¹ã‚¤ãƒƒãƒæ“ä½œç›´å¾Œãªã©ã€å®šå¸¸çŠ¶æ…‹ã«é”ã™ã‚‹ã¾ã§ã®æ™‚é–“å¤‰åŒ–ã‚’è¨˜è¿°ã—ã¾ã™ã€‚ç·šå½¢å¾®åˆ†æ–¹ç¨‹å¼ã‚’è§£ãã“ã¨ã§è§£æã—ã¾ã™ã€‚</p>

            <h3>RCç›´åˆ—å›è·¯ã®å……é›»éç¨‹</h3>
            <p>æŠµæŠ— \(R\) ã¨ã‚³ãƒ³ãƒ‡ãƒ³ã‚µãƒ¼ \(C\) ã®ç›´åˆ—å›è·¯ã«ã€æ™‚åˆ» \(t=0\) ã§ç›´æµé›»åœ§ \(E\) ã‚’å°åŠ ã—ãŸå ´åˆã®é›»åœ§æ–¹ç¨‹å¼ï¼ˆKVLï¼‰ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</p>
            <div class="box">
                $$R i(t) + \frac{1}{C} \int i(t) dt = E$$
                ä¸¡è¾ºã‚’æ™‚é–“å¾®åˆ†ã—ã¦æ•´ç†ã™ã‚‹ã¨ã€é›»æµ \(i(t)\) ã«é–¢ã™ã‚‹1éšç·šå½¢å¾®åˆ†æ–¹ç¨‹å¼ãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚
                $$R \frac{di}{dt} + \frac{1}{C} i = 0$$
                <strong>è§£:</strong>
                $$i(t) = \frac{E}{R} e^{-\frac{t}{RC}}, \quad v_C(t) = E (1 - e^{-\frac{t}{RC}})$$
            </div>
            <p>ã“ã“ã§ã€ç© \( \tau = RC \) ã‚’<strong>æ™‚å®šæ•° (Time Constant)</strong> ã¨å‘¼ã³ã€å¿œç­”ã®é€Ÿã•ã‚’è¡¨ã—ã¾ã™ã€‚</p>

            <h3>RLç›´åˆ—å›è·¯ã®å¿œç­”</h3>
            <div class="box">
                $$L \frac{di}{dt} + Ri = E$$
                <strong>è§£ (é›»æµ):</strong>
                $$i(t) = \frac{E}{R} (1 - e^{-\frac{R}{L}t})$$
            </div>
            <p>æ™‚å®šæ•°ã¯ \( \tau = \frac{L}{R} \) ã§ã™ã€‚</p>

            <h2>4. äº¤æµå›è·¯ã¨è¤‡ç´ ã‚¤ãƒ³ãƒ”ãƒ¼ãƒ€ãƒ³ã‚¹ (AC & Complex Impedance)</h2>
            <p>è§’å‘¨æ³¢æ•° \(\omega\) ã®æ­£å¼¦æ³¢äº¤æµå®šå¸¸çŠ¶æ…‹ã«ãŠã„ã¦ã€é›»åœ§ã¨é›»æµã‚’è¤‡ç´ æ•°ï¼ˆãƒ•ã‚§ãƒ¼ã‚¶ï¼‰ã§æ‰±ã†ã“ã¨ã§ã€å¾®åˆ†æ–¹ç¨‹å¼ã‚’ä»£æ•°æ–¹ç¨‹å¼ã¨ã—ã¦è§£ãã“ã¨ãŒã§ãã¾ã™ï¼ˆã‚ªã‚¤ãƒ©ãƒ¼ã®å…¬å¼ \(e^{j\theta} = \cos\theta + j\sin\theta\) ã®å¿œç”¨ï¼‰ã€‚</p>

            <div class="box">
                <strong>ã‚¤ãƒ³ãƒ”ãƒ¼ãƒ€ãƒ³ã‚¹ \(Z\) ã®å®šç¾©:</strong> $$\dot{V} = Z \dot{I}$$
                <ul>
                    <li>æŠµæŠ—: \( Z_R = R \) ï¼ˆä½ç›¸å·®ãªã—ï¼‰</li>
                    <li>ã‚³ã‚¤ãƒ«: \( Z_L = j\omega L \) ï¼ˆé›»åœ§ãŒé›»æµã‚ˆã‚Š \(\pi/2\) é€²ã‚€ï¼‰</li>
                    <li>ã‚³ãƒ³ãƒ‡ãƒ³ã‚µãƒ¼: \( Z_C = \frac{1}{j\omega C} = -j\frac{1}{\omega C} \) ï¼ˆé›»åœ§ãŒé›»æµã‚ˆã‚Š \(\pi/2\) é…ã‚Œã‚‹ï¼‰</li>
                </ul>
                <small>â€»é›»æ°—å·¥å­¦ã§ã¯è™šæ•°å˜ä½ã« \(i\) ã§ã¯ãªã \(j\) ã‚’ç”¨ã„ã¾ã™ã€‚</small>
            </div>

            <h3>RLCç›´åˆ—å›è·¯ã¨å…±æŒ¯</h3>
            <p>åˆæˆã‚¤ãƒ³ãƒ”ãƒ¼ãƒ€ãƒ³ã‚¹ \(Z\) ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</p>
            <div class="box">
                $$Z = R + j\left( \omega L - \frac{1}{\omega C} \right)$$
                å›è·¯ã‚’æµã‚Œã‚‹é›»æµã®å¤§ãã•ã¯ \( |I| = \frac{|V|}{\sqrt{R^2 + (\omega L - \frac{1}{\omega C})^2}} \) ã¨ãªã‚Šã¾ã™ã€‚
            </div>
            <p>è™šéƒ¨ãŒã‚¼ãƒ­ã«ãªã‚‹å‘¨æ³¢æ•° \( \omega_0 = \frac{1}{\sqrt{LC}} \) ã«ãŠã„ã¦ã‚¤ãƒ³ãƒ”ãƒ¼ãƒ€ãƒ³ã‚¹ãŒæœ€å°ï¼ˆ\(Z=R\)ï¼‰ã¨ãªã‚Šã€é›»æµãŒæœ€å¤§åŒ–ã—ã¾ã™ã€‚ã“ã‚Œã‚’<strong>ç›´åˆ—å…±æŒ¯</strong>ã¨å‘¼ã³ã¾ã™ã€‚</p>

            <h2>5. é›»åŠ› (Power)</h2>
            <div class="box">
                <ul>
                    <li><strong>ç¬æ™‚é›»åŠ›:</strong> \( p(t) = v(t)i(t) \)</li>
                    <li><strong>æœ‰åŠ¹é›»åŠ› (Active Power) \(P\):</strong> å®Ÿéš›ã«æ¶ˆè²»ã•ã‚Œã‚‹é›»åŠ›ã®å¹³å‡å€¤ã€‚å˜ä½ã¯ãƒ¯ãƒƒãƒˆ[W]ã€‚
                    $$P = V_{eff} I_{eff} \cos \phi$$
                    ï¼ˆ\(\cos \phi\) ã¯åŠ›ç‡ï¼‰</li>
                    <li><strong>ç„¡åŠ¹é›»åŠ› (Reactive Power) \(Q\):</strong> é›»æºã¨ç´ å­ã®é–“ã‚’å¾€å¾©ã™ã‚‹ã ã‘ã®é›»åŠ›ã€‚å˜ä½ã¯ãƒãƒ¼ãƒ«[var]ã€‚
                    $$Q = V_{eff} I_{eff} \sin \phi$$
                    </li>
                    <li><strong>çš®ç›¸é›»åŠ› (Apparent Power) \(S\):</strong> å›è·¯è¨­è¨ˆä¸Šã®å®¹é‡ã€‚å˜ä½ã¯ãƒœãƒ«ãƒˆã‚¢ãƒ³ãƒšã‚¢[VA]ã€‚
                    $$S = \sqrt{P^2 + Q^2} = V_{eff} I_{eff}$$
                    </li>
                </ul>
            </div>
	    <h2>6. å¿œç”¨çŸ¥è­˜ï¼šç†æƒ³ã¨ç¾å®Ÿã®ã‚®ãƒ£ãƒƒãƒ— (Applied Knowledge)</h2>
            <p>ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã‚„æ•™ç§‘æ›¸ã§æ‰±ã†ã€Œç†æƒ³çš„ãªç´ å­ã€ã¨ã€ç¾å®Ÿä¸–ç•Œã®ã€Œãƒªã‚¢ãƒ«ãªç´ å­ã€ã«ã¯é•ã„ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã§ã¯ã€ãã®é•ã„ã‚’æ„å›³çš„ã«å†ç¾ãƒ»è¦³å¯Ÿã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</p>

            <h3>æµ®éŠãƒãƒ¼ãƒ‰ (Floating Node)</h3>
            <div class="box">
                <p><strong>ç¾è±¡:</strong> å›è·¯ã®ä¸€éƒ¨ãŒã€é›»æºã®åŸºæº–é›»ä½ï¼ˆã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãªã©ï¼‰ã‹ã‚‰é›»æ°—çš„ã«å®Œå…¨ã«åˆ‡ã‚Šé›¢ã•ã‚Œã¦ã„ã‚‹çŠ¶æ…‹ã§ã™ã€‚</p>
                <p><strong>ãªãœå•é¡Œã‹:</strong> é›»ä½ï¼ˆé›»åœ§ã®é«˜ã•ï¼‰ã¯ã€Œç›¸å¯¾çš„ãªå·®ã€ã§ã—ã‹æ±ºã¾ã‚Šã¾ã›ã‚“ã€‚åŸºæº–ã¨ãªã‚‹0måœ°ç‚¹ãŒæ±ºã¾ã£ã¦ã„ãªã„é¢¨èˆ¹ã®é«˜åº¦ãŒå®šã¾ã‚‰ãªã„ã‚ˆã†ã«ã€æµ®éŠãƒãƒ¼ãƒ‰ã®é›»ä½ã¯è¨ˆç®—ä¸Šã®èª¤å·®ã‚„ã‚ãšã‹ãªé™é›»æ°—ãƒã‚¤ã‚ºã«ã‚ˆã£ã¦ä¸å®šã¨ãªã‚Šã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ä¸Šã§ã¯ç•°å¸¸ãªé›»åœ§å€¤ï¼ˆãƒ‰ãƒªãƒ•ãƒˆç¾è±¡ï¼‰ã¨ã—ã¦è¦³æ¸¬ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</p>
            </div>

            <h3>æ¼ã‚ŒæŠµæŠ— (Leakage Resistance)</h3>
            <div class="box">
                <p><strong>ç†æƒ³:</strong> ã‚³ãƒ³ãƒ‡ãƒ³ã‚µãƒ¼ã¯ç›´æµé›»æµã‚’å®Œå…¨ã«é®æ–­ã™ã‚‹ã€Œçµ¶ç¸ä½“ã€ã§ã™ï¼ˆæŠµæŠ—å€¤ \(R = \infty\)ï¼‰ã€‚</p>
                <p><strong>ç¾å®Ÿ:</strong> å®Ÿéš›ã®ã‚³ãƒ³ãƒ‡ãƒ³ã‚µãƒ¼ã‚„ç©ºæ°—çµ¶ç¸ã¯ã€æ¥µã‚ã¦é«˜ã„æŠµæŠ—å€¤ï¼ˆæ•°M\(\Omega\) ã€œ æ•°G\(\Omega\)ï¼‰ã‚’æŒã£ã¦ã„ã¾ã™ãŒã€å®Œå…¨ãªçµ¶ç¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã”ãã‚ãšã‹ã«é›»æµãŒæ¼ã‚Œã¦ã„ã¾ã™ã€‚</p>
                <p><strong>å½¹å‰²:</strong> ã“ã®å¾®å°ãªæ¼ã‚Œé›»æµã®ãŠã‹ã’ã§ã€æµ®éŠãƒãƒ¼ãƒ‰ã«æºœã¾ã£ãŸä½™åˆ†ãªé›»è·ãŒé€ƒã’ã‚‹ã“ã¨ãŒã§ãã€ç¾å®Ÿã®å›è·¯ã§ã¯é›»ä½ãŒå®‰å®šã—ã¾ã™ã€‚</p>
            </div>

            <h3>æ¥åœ° (Ground / Earth)</h3>
            <div class="box">
                <p><strong>å®šç¾©:</strong> å›è·¯ç¶²ã®ä¸­ã§ã€Œã“ã“ã‚’0Vã¨ã™ã‚‹ã€ã¨æ±ºã‚ãŸåŸºæº–ç‚¹ã§ã™ã€‚è¨˜å· \(\perp\) ã‚„ \(\bumpeq\) ã§è¡¨ã•ã‚Œã¾ã™ã€‚</p>
                <p><strong>é‡è¦æ€§:</strong> æ¥åœ°ã‚’è¡Œã†ã“ã¨ã§ã€å›è·¯å…¨ä½“ã®é›»ä½ã®åŸºæº–ãŒç¢ºå®šã—ã€å‹•ä½œãŒå®‰å®šã—ã¾ã™ã€‚ã¾ãŸã€æ„Ÿé›»é˜²æ­¢ã‚„ãƒã‚¤ã‚ºå¯¾ç­–ã¨ã—ã¦ã‚‚é‡è¦ã§ã™ã€‚</p>
            </div>

            <h3>ğŸ§ª æœ¬ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã§ã®å­¦ç¿’ãƒ»å®Ÿé¨“æ–¹æ³•</h3>
            <p>ã“ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã«ã¯ã€ç¾å®Ÿã®æŒ™å‹•ã‚’å†ç¾ã™ã‚‹ãŸã‚ã®æ©Ÿèƒ½ãŒå‚™ã‚ã£ã¦ã„ã¾ã™ã€‚</p>
            <ul>
                <li><strong>å®Ÿé¨“1: æµ®éŠãƒãƒ¼ãƒ‰ã®è¦³å¯Ÿ</strong><br>
                ã‚³ãƒ³ãƒ‡ãƒ³ã‚µãƒ¼ã‚’ç›´åˆ—ã«ç¹‹ãã€ä¸¡ç«¯ã«é›»æ± ã‚’ç¹‹ãã¾ã™ã€‚ã‚³ãƒ³ãƒ‡ãƒ³ã‚µãƒ¼åŒå£«ã®ä¸­ç‚¹ï¼ˆæµ®éŠãƒãƒ¼ãƒ‰ï¼‰ã®é›»åœ§ã‚’è¦‹ã‚‹ã¨ã€å€¤ãŒå®šã¾ã‚‰ãªã‹ã£ãŸã‚Šã€ã‚†ã£ãã‚Šå¤‰å‹•ã—ãŸã‚Šã™ã‚‹æ§˜å­ãŒè¦³å¯Ÿã§ãã¾ã™ã€‚ã“ã‚Œã¯ã€Œæ¼ã‚ŒæŠµæŠ—ã€ãŒOFFï¼ˆç†æƒ³çŠ¶æ…‹ï¼‰ã ã‹ã‚‰ã§ã™ã€‚</li>
                
                <li><strong>å®Ÿé¨“2: æ¼ã‚ŒæŠµæŠ—ã®åŠ¹æœ</strong><br>
                ã‚³ãƒ³ãƒ‡ãƒ³ã‚µãƒ¼ã‚’é¸æŠã—ã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ç”»é¢ã§<strong>ã€Œæ¼ã‚ŒæŠµæŠ—(Real): ONã€</strong>ã«åˆ‡ã‚Šæ›¿ãˆã¦ãã ã•ã„ã€‚å†…éƒ¨ã§ \(100\text{M}\Omega\) ã®æŠµæŠ—ãŒä¸¦åˆ—æ¥ç¶šã•ã‚Œã€ä¸å®‰å®šã ã£ãŸé›»åœ§ãŒãƒ”ã‚¿ãƒªã¨å®‰å®šã™ã‚‹æ§˜å­ãŒç¢ºèªã§ãã¾ã™ã€‚</li>
                
                <li><strong>å®Ÿé¨“3: æ¥åœ°ã«ã‚ˆã‚‹é›»ä½ã®ç¢ºå®š</strong><br>
                ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‹ã‚‰<strong>ã€Œæ¥åœ° (GND)ã€</strong>ã‚’è¿½åŠ ã—ã€å›è·¯ã®ä»»æ„ã®å ´æ‰€ã«æ¥ç¶šã—ã¦ãã ã•ã„ã€‚ãã“ãŒå¼·åˆ¶çš„ã«0Vã¨ãªã‚Šã€ãã“ã‚’åŸºæº–ã¨ã—ãŸé›»åœ§åˆ†å¸ƒã«å¤‰åŒ–ã—ã¾ã™ã€‚</li>
            </ul>
ã€€ã€€ã€€ã€€ã€€ã€€ã€€<!--
	    ### ä¿®æ­£å¾Œã®ç¢ºèªãƒã‚¤ãƒ³ãƒˆ
	    ã‚³ãƒ¼ãƒ‰ã‚’æŒ¿å…¥ã—ãŸå¾Œã€ãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ãç›´ã—ã€ä»¥ä¸‹ã®æ‰‹é †ã§å‹•ä½œã¨è§£èª¬ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚
	    1.  **ã€ŒåŸºç¤çŸ¥è­˜ã€ã‚¿ãƒ–** ã‚’ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ã€ä¸€ç•ªä¸‹ã«ã€Œ6. å¿œç”¨çŸ¥è­˜...ã€ãŒè¿½åŠ ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã€‚
	    2.  **ã€Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã€ã‚¿ãƒ–** ã«ç§»å‹•ã—ã€ä»¥ä¸‹ã®æ“ä½œã‚’è¡Œã†ã€‚
	    * ã‚³ãƒ³ãƒ‡ãƒ³ã‚µãƒ¼2ã¤ã‚’ç›´åˆ—ã«é…ç½®ã—ã€é›»æºã«ã¤ãªãã€‚
	    * ã‚³ãƒ³ãƒ‡ãƒ³ã‚µãƒ¼ã‚’é¸æŠã—ã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ‘ãƒãƒ«ã«å‡ºã‚‹ **ã€Œæ¼ã‚ŒæŠµæŠ—(Real): OFFã€** ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ **ON** ã«ã™ã‚‹ã€‚
	    * é›»åœ§è¨ˆã®æ•°å€¤ãŒå®‰å®šã™ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã€‚
	    * **ã€Œæ¥åœ° (GND)ã€** ã‚¢ã‚¤ã‚³ãƒ³ã‚’ä½¿ã£ã¦å›è·¯ã®ä¸€éƒ¨ã‚’æ¥åœ°ã—ã€å‹•ä½œãŒå¤‰ã‚ã‚‰ãªã„ã“ã¨ï¼ˆã¾ãŸã¯é›»ä½ã®åŸºæº–ãŒå¤‰ã‚ã‚‹ã“ã¨ï¼‰ã‚’ç¢ºèªã™ã‚‹ã€‚
	    ã“ã®ä¿®æ­£ã«ã‚ˆã‚Šã€å­¦ç”Ÿã¯ã€Œãªãœã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒä¸å®‰å®šã«ãªã‚‹ã®ã‹ã€ã¨ã„ã†ç–‘å•ã‹ã‚‰å‡ºç™ºã—ã€é›»æ°—å›è·¯ã®æ·±ã„ç†è§£ï¼ˆç†æƒ³ãƒ¢ãƒ‡ãƒ«ã¨ç¾å®Ÿãƒ¢ãƒ‡ãƒ«ã®é•ã„ï¼‰ã¸ã¨é€²ã‚€ã“ã¨ãŒã§ãã‚‹ç´ æ™´ã‚‰ã—ã„æ•™æã«ãªã‚Šã¾ã™ã€‚	    
            -->
        </div>
    </div>

    <div id="simulation-pane" class="tab-pane">
        <div id="sim-sidebar">
            <h2>å®Ÿè¡Œåˆ¶å¾¡</h2>
            <div class="control-panel">
                <button class="ctrl-btn btn-start" onclick="startSim()">â–¶ é–‹å§‹</button>
                <button class="ctrl-btn btn-stop" onclick="stopSim()">â¸ åœæ­¢</button>
		<button class="ctrl-btn" style="background:#8e44ad;" onclick="stepSim()">â–¶| ã‚¹ãƒ†ãƒƒãƒ—</button>
                <button class="ctrl-btn btn-reset" onclick="resetSim()">âŸ² ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
	    <button class="btn-toggle-all" style="background:#8e44ad; margin-bottom:5px;" onclick="toggleNetView()">ğŸ” æ¥ç¶šãƒã‚§ãƒƒã‚¯ (è‰²åˆ†ã‘)</button>
            <button class="btn-toggle-all" onclick="toggleAllSwitches()">âš¡ å…¨ã‚¹ã‚¤ãƒƒãƒåˆ‡æ›¿</button>

            <div id="properties">
                <span style="font-weight:bold; color:#bdc3c7; display:block; margin-bottom:10px; border-bottom:1px solid #566b80;">ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£</span>
                <div id="prop-content" style="min-height: 80px; display:flex; flex-direction: column; align-items:center; justify-content:center; color:#95a5a6; font-size:12px;">éƒ¨å“ã‚’é¸æŠ</div>
                <div style="margin-top:15px; display:flex; gap:5px;">
                    <button onclick="deleteSelected()" style="background:#e74c3c; border:none; color:white; padding:8px; border-radius:4px; flex:1; cursor:pointer;">å‰Šé™¤</button>
                    <button onclick="clearWires()" style="background:#f39c12; border:none; color:white; padding:8px; border-radius:4px; flex:1; cursor:pointer;">å…¨é…ç·šæ¶ˆå»</button>
                </div>
            </div>

            <h2>ãƒ„ãƒ¼ãƒ«</h2>
            <div class="btn-group">
                <button onclick="setTool('select')" id="btn-select" class="sim-btn active"><span class="icon">â¤</span>é¸æŠ / ç§»å‹•</button>
                <button onclick="rotateSelected()" class="sim-btn"><span class="icon">â†»</span>å›è»¢ (R)</button>
		<button onclick="addPart('ground')" class="sim-btn"><span class="icon">âš</span>æ¥åœ° (GND)</button>
                <button onclick="setTool('wire')" id="btn-wire" class="sim-btn"><span class="icon">âœ</span>ãƒ¯ã‚¤ãƒ¤ãƒ¼ (é…ç·š)</button>
            </div>
            
            <h2>ç´ å­</h2>
            <div class="btn-group">
                <button onclick="addPart('source')" class="sim-btn"><span class="icon">â“</span>ç›´æµé›»æº</button>
                <button onclick="addPart('ac_source')" class="sim-btn"><span class="icon">âˆ¼</span>äº¤æµé›»æº</button>
                <button onclick="addPart('switch')" class="sim-btn"><span class="icon">_/_</span>ã‚¹ã‚¤ãƒƒãƒ</button>
                <button onclick="addPart('resistor')" class="sim-btn"><span class="icon">R</span>æŠµæŠ—</button>
                <button onclick="addPart('capacitor')" class="sim-btn"><span class="icon">C</span>ã‚³ãƒ³ãƒ‡ãƒ³ã‚µãƒ¼</button>
                <button onclick="addPart('inductor')" class="sim-btn"><span class="icon">L</span>ã‚³ã‚¤ãƒ«</button>
		<button onclick="addPart('diode')" class="sim-btn"><span class="icon">D</span>ãƒ€ã‚¤ã‚ªãƒ¼ãƒ‰</button>
		<button onclick="addPart('led')" class="sim-btn"><span class="icon">â˜€</span>LED</button>
		<button onclick="addPart('npn')" class="sim-btn"><span class="icon">T</span>NPN Tr</button>
            </div>
            <h2>è¨ˆæ¸¬å™¨</h2>
            <div class="btn-group">
                <button onclick="addPart('voltmeter')" class="sim-btn"><span class="icon">V</span>é›»åœ§è¨ˆ</button>
                <button onclick="addPart('ammeter')" class="sim-btn"><span class="icon">A</span>é›»æµè¨ˆ</button>
                <button onclick="addPart('galvanometer')" class="sim-btn"><span class="icon">G</span>æ¤œæµè¨ˆ</button>
            </div>
        </div>

        <div id="main-view">
            <div id="canvas-wrapper">
                <canvas id="circuitCanvas"></canvas>
                <div class="sim-info">
                    <span id="sim-status-badge" class="status-badge status-stopped">åœæ­¢ä¸­</span>
                    <strong style="color:#2c3e50; font-size:14px;">é…ç·šã®ã‚³ãƒ„ (ç›´äº¤ãƒ¢ãƒ¼ãƒ‰)</strong><br>
                    <div style="margin-top:8px; line-height:1.4; color:#555;">
                    1. é…ç·šã¯è‡ªå‹•çš„ã«<span style="color:#3498db;font-weight:bold;">ç¸¦ãƒ»æ¨ª(Lå­—)</span>ã«ãªã‚Šã¾ã™<br>
                    2. ä½•ã‚‚ãªã„æ‰€ã¾ã§ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦æ”¾ã™ã¨<br>
                       <span style="color:#e67e22; font-weight:bold;">â— ä¸­ç¶™ç‚¹ (Joint)</span> ã‚’ä½œæˆã—ã¾ã™<br>
                    3. ã“ã‚Œã§éšœå®³ç‰©ã‚’é¿ã‘ã¦é…ç·šã§ãã¾ã™
                    </div>
                </div>
            </div>
            <div id="graph-wrapper">
                <div style="font-size:12px; color:#555; margin-bottom:2px; display:flex; justify-content:space-between; height: 20px;">
                    <strong>æ³¢å½¢æ¯”è¼ƒãƒ¢ãƒ‹ã‚¿ãƒ¼</strong><span id="graph-legend">ç´ å­ã‚’1ã¤é¸æŠã™ã‚‹ã¨ã‚°ãƒ©ãƒ•ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</span>
                </div>
                <canvas id="graphCanvas"></canvas>
            </div>
        </div>
    </div>
</div>

<script>
    function renderLatexInElement(element) {
        if (typeof renderMathInElement === 'function' && element) {
            try { renderMathInElement(element, { delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}], throwOnError: false }); } catch (e) {}
        }
    }

    function switchTab(tabId) {
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.remove('active');
            if(btn.innerText.includes(tabId === 'theory' ? 'åŸºç¤' : 'ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³')) btn.classList.add('active');
        });
        document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
        if(tabId === 'theory') document.getElementById('theory-pane').classList.add('active');
        else {
            document.getElementById('simulation-pane').classList.add('active');
            setTimeout(() => { resize(); resizeGraph(); }, 0);
        }
    }

    const canvas = document.getElementById('circuitCanvas');
    const ctx = canvas.getContext('2d');
    const graphCanvas = document.getElementById('graphCanvas');
    const gCtx = graphCanvas.getContext('2d');

    let mouseDownPos = { x: 0, y: 0 }; // â˜…è¿½åŠ : ã‚¯ãƒªãƒƒã‚¯åˆ¤å®šç”¨
    
    let width, height, graphW, graphH;
    const parts = []; let wires = []; const nodes = [];   
    let selectedParts = []; let currentTool = 'select';
    let isDragging = false; let dragStartNode = null;
    let lastMousePos = { x: 0, y: 0 }; let mousePos = { x: 0, y: 0 }; let hoverNode = null;
    let isBoxSelecting = false; let selectionBox = { x: 0, y: 0, w: 0, h: 0 };

    let isRunning = false; let simTime = 0; const dt = 0.0001; let animationOffset = 0; 
    const ITERATIONS = 5000; const INTERNAL_R_SRC = 1e-5; const R_SWITCH_CLOSED = 1e-5;
    // â˜…â˜…â˜… è¿½åŠ ã‚³ãƒ¼ãƒ‰: åœæ­¢ä¸­ã®è¨ˆç®—åˆ¶å¾¡ç”¨ â˜…â˜…â˜…
    let updateFrames = 0; // å†è¨ˆç®—ãŒå¿…è¦ãªæ®‹ã‚Šãƒ•ãƒ¬ãƒ¼ãƒ æ•°
    function triggerUpdate() { updateFrames = 5; } // æ“ä½œãŒã‚ã£ãŸã‚‰5ãƒ•ãƒ¬ãƒ¼ãƒ ã ã‘è¨ˆç®—ã‚’è¨±å¯ã™ã‚‹é–¢æ•°
  
    const R_SWITCH_OPEN = 1e9; const INTERNAL_R_AMMETER = 1e-5; const G_LEAK = 1e-12;            
    const MAX_HISTORY = 400; const historyData = []; const GRID_SIZE = 20;

    // â˜…â˜…â˜… è¿½åŠ ã‚³ãƒ¼ãƒ‰: æ¥ç¶šãƒã‚§ãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰ç®¡ç† â˜…â˜…â˜…
    let isNetViewMode = false;
    function toggleNetView() {
        isNetViewMode = !isNetViewMode;
        draw();
    }
    // NetIdã‹ã‚‰è‰²ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
    function getNetColor(netId) {
        if (netId === -1) return "#999"; // æœªæ¥ç¶š
        const hue = (netId * 137.508) % 360; // é»„é‡‘è§’ã§è‰²ã‚’æ•£ã‚‰ã™
        return `hsl(${hue}, 70%, 50%)`;
    }

    function formatValue(val, unit, useAbs = true) {
        let v = useAbs ? Math.abs(val) : val;
        if (Math.abs(v) < 1e-5) v = 0;   // â˜…ä¿®æ­£: 1ÂµV (1e-6) æœªæº€ã®ãƒã‚¤ã‚ºã¯ 0 ã¨ã¿ãªã—ã¦è¡¨ç¤ºã™ã‚‹
        let sign = (v < 0) ? "-" : ""; let absVal = Math.abs(v); let prefix = "";
        if (absVal < 1e-9 && absVal !== 0) { absVal *= 1e12; prefix = "p"; }
        else if (absVal < 1e-6 && absVal !== 0) { absVal *= 1e9; prefix = "n"; }
        else if (absVal < 1e-3 && absVal !== 0) { absVal *= 1e6; prefix = "Âµ"; }
        else if (absVal < 1 && absVal !== 0) { absVal *= 1e3; prefix = "m"; }
        else if (absVal >= 1e3 && absVal < 1e6) { absVal /= 1e3; prefix = "k"; }
        else if (absVal >= 1e6) { absVal /= 1e6; prefix = "M"; }
        return sign + absVal.toFixed(2) + " " + prefix + unit;
    }

    class Node {
        constructor(parentPart, offsetX, offsetY) {
            this.parentPart = parentPart; this.offsetX = offsetX; this.offsetY = offsetY;
            this.voltage = 0; this.netId = -1;
        }
        get x() { const cos = Math.cos(this.parentPart.rotation), sin = Math.sin(this.parentPart.rotation); return this.parentPart.x + (this.offsetX * cos - this.offsetY * sin); }
        get y() { const cos = Math.cos(this.parentPart.rotation), sin = Math.sin(this.parentPart.rotation); return this.parentPart.y + (this.offsetX * sin + this.offsetY * cos); }
    }

    class Part {
        constructor(type, x, y) {
            this.type = type; this.x = x; this.y = y; this.rotation = 0; 
            this.nodes = []; this.value = 0; this.label = ""; this.current = 0; 
            this.freq = 1.0; this.amplitude = 10; this.voltageState = 0; this.isOpen = false; 
            
            // ã‚³ãƒ³ãƒ‡ãƒ³ã‚µãƒ¼ç”¨è¿½åŠ ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
            this.cap_d = 1.0; // æ¥µæ¿é–“è·é›¢ (ç›¸å¯¾å€¤)
            this.cap_s = 1.0; // æ¥µæ¿é¢ç© (ç›¸å¯¾å€¤)
            this.cap_e = 1.0; // æ¯”èª˜é›»ç‡
            this.cap_x = 0.0; // èª˜é›»ä½“æŒ¿å…¥ç‡ (0.0 - 1.0)
            this.base_C = 10.0; // åŸºæº–å®¹é‡ (ÂµF)

            this.initType();
        }
        initType() {
            switch(this.type) {
                case 'source': this.nodes.push(new Node(this, -40, 0)); this.nodes.push(new Node(this, 40, 0)); this.value = 10; this.label = "10V"; break;
                case 'ac_source': this.nodes.push(new Node(this, -40, 0)); this.nodes.push(new Node(this, 40, 0)); this.amplitude = 10; this.freq = 1.0; this.label = "10V\n1Hz"; break;
                case 'switch': this.nodes.push(new Node(this, -30, 0)); this.nodes.push(new Node(this, 30, 0)); this.label = "SW"; this.isOpen = false; break;
                case 'resistor': this.nodes.push(new Node(this, -40, 0)); this.nodes.push(new Node(this, 40, 0)); this.value = 100; this.label = "100Î©"; break;
		// â˜…å¤‰æ›´: ã‚³ãƒ³ãƒ‡ãƒ³ã‚µãƒ¼ã«ã€Œç†æƒ³ãƒ¢ãƒ¼ãƒ‰(æ¼ã‚Œãªã—)ã€ãƒ•ãƒ©ã‚°ã‚’è¿½åŠ 
                case 'capacitor': 
                    this.nodes.push(new Node(this, -20, 0)); this.nodes.push(new Node(this, 20, 0)); 
                    this.value = 10; 
                    this.label = "10.0ÂµF";
                    this.useLeakage = true; // â˜…è¿½åŠ : ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§æ¼ã‚ŒæŠµæŠ—ON
                break;
		// â˜…è¿½åŠ : ã‚¢ãƒ¼ã‚¹(Ground)ã®å®šç¾©
                case 'ground':
                    this.nodes.push(new Node(this, 0, -10)); // ä¸Šã«æ¥ç¶šç‚¹
                    this.label = "GND";
                break;
                case 'inductor': this.nodes.push(new Node(this, -30, 0)); this.nodes.push(new Node(this, 30, 0)); this.value = 1; this.label = "1H"; break;
		case 'diode':
                    this.nodes.push(new Node(this, -20, 0)); // Anode
                    this.nodes.push(new Node(this, 20, 0));  // Cathode
                    this.label = "Diode";
                    break;
                case 'led':
                    this.nodes.push(new Node(this, -20, 0)); // Anode
                    this.nodes.push(new Node(this, 20, 0));  // Cathode
                    this.label = "LED";
                    this.color = "#e74c3c"; // Red
                    break;
                case 'npn':
                // Node 0: Base, 1: Collector, 2: Emitter
                    this.nodes.push(new Node(this, -20, 0));   // Base (Left)
                    this.nodes.push(new Node(this, 20, -20));  // Collector (Top-Right)
                    this.nodes.push(new Node(this, 20, 20));   // Emitter (Bottom-Right)
                    this.value = 100; // Beta (hFE)
                    this.label = "hFE=100";
                    break;
                case 'voltmeter': this.nodes.push(new Node(this, -30, 0)); this.nodes.push(new Node(this, 30, 0)); this.value = 1e6; this.label = "Vm"; break;
                case 'ammeter': this.nodes.push(new Node(this, -30, 0)); this.nodes.push(new Node(this, 30, 0)); this.value = INTERNAL_R_AMMETER; this.label = "Am"; break;
                case 'galvanometer': this.nodes.push(new Node(this, -30, 0)); this.nodes.push(new Node(this, 30, 0)); this.value = 5; this.label = "G"; break;
                case 'joint': this.nodes.push(new Node(this, 0, 0)); this.label = ""; break; 
            }
            this.nodes.forEach(n => nodes.push(n));
        }
        
        rotate() { this.rotation += Math.PI / 2; if (this.rotation > Math.PI) this.rotation -= Math.PI * 2; }
        getVoltageDiff() { if(this.nodes.length<2) return 0; return this.nodes[0].voltage - this.nodes[1].voltage; }
        getCharge() { if (this.type !== 'capacitor') return 0; return (this.value * 1e-6) * this.getVoltageDiff(); }

        draw(ctx) {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
            if (selectedParts.includes(this)) {
                ctx.shadowBlur = 10; ctx.shadowColor = "#3498db"; ctx.strokeStyle = "rgba(52, 152, 219, 0.8)"; ctx.lineWidth = 2;
                if(this.type === 'joint') ctx.strokeRect(-8, -8, 16, 16);
                else ctx.strokeRect(-50, -35, 100, 70);
                ctx.shadowBlur = 0;
                
                if(this.type !== 'joint' && this.nodes.length >= 2) {
                    ctx.fillStyle = "#e74c3c"; ctx.font = "bold 14px Arial"; ctx.fillText("+", this.nodes[0].offsetX, -25);
                    ctx.fillStyle = "#3498db"; ctx.fillText("-", this.nodes[1].offsetX, -25);
                    if (!['voltmeter'].includes(this.type)) {
                        ctx.strokeStyle = "#f39c12"; ctx.lineWidth = 2; ctx.beginPath();
                        let n0x = this.nodes[0].offsetX, n1x = this.nodes[1].offsetX;
                        ctx.moveTo(n0x + 10, 20); ctx.lineTo(n1x - 10, 20); ctx.lineTo(n1x - 15, 17); ctx.moveTo(n1x - 10, 20); ctx.lineTo(n1x - 15, 23);
                        ctx.stroke(); ctx.fillStyle = "#f39c12"; ctx.font = "10px Arial"; ctx.fillText("I (+)", 0, 28);
                    }
                }
            }
            if (isRunning && Math.abs(this.current) > 1e-9 && !['voltmeter', 'joint'].includes(this.type)) {
                const speed = this.current * 100; const dotOffset = (animationOffset * speed) % 20;
                ctx.fillStyle = "#f1c40f"; ctx.beginPath();
                for(let lx = -30; lx <= 30; lx += 15) {
                    let drawX = lx + dotOffset; if (drawX > 30) drawX -= 60; if (drawX < -30) drawX += 60;
                    if (drawX >= -35 && drawX <= 35) ctx.arc(drawX, 0, 2.5, 0, Math.PI*2);
                }
                ctx.fill();
            }
            
            if(this.type === 'joint') {
                ctx.fillStyle = "#2c3e50"; ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill();
            } else {
                ctx.strokeStyle = "#2c3e50"; ctx.lineWidth = 2; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                this.nodes.forEach(n => {
                    ctx.beginPath();
                    let startX = (n.offsetX > 0) ? n.offsetX - 10 : n.offsetX + 10;
                    
                    // ã‚³ãƒ³ãƒ‡ãƒ³ã‚µãƒ¼ã®å ´åˆã€æ¥µæ¿ã®ä½ç½®ã«åˆã‚ã›ã¦ç«¯å­ç·šã®é•·ã•ã‚’å¤‰ãˆã‚‹
                    if (this.type === 'capacitor') {
                        const plateOff = Math.min(15, Math.max(2, 5 * this.cap_d)); 
                        startX = (n.offsetX > 0) ? plateOff : -plateOff;
                    }
                    else if (this.type === 'switch') startX = (n.offsetX > 0) ? n.offsetX - 10 : n.offsetX + 10;
                    
                    ctx.moveTo(startX, n.offsetY); ctx.lineTo(n.offsetX, n.offsetY); ctx.stroke();
                    ctx.beginPath(); ctx.fillStyle = "#2c3e50"; ctx.arc(n.offsetX, n.offsetY, 4, 0, Math.PI*2); ctx.fill();
                });
                ctx.beginPath();
                if (this.type === 'resistor') { ctx.moveTo(-30, 0); for(let i=0; i<6; i++) ctx.lineTo(-25 + i*10, (i%2==0 ? -1 : 1) * 10); ctx.lineTo(30, 0); ctx.stroke(); } 
                else if (this.type === 'switch') { ctx.moveTo(-30, 0); ctx.lineTo(-20, 0); ctx.moveTo(30, 0); ctx.lineTo(20, 0); ctx.stroke(); ctx.beginPath(); if (this.isOpen) { ctx.moveTo(-20, 0); ctx.lineTo(15, -15); } else { ctx.moveTo(-20, 0); ctx.lineTo(20, 0); } ctx.stroke(); ctx.beginPath(); ctx.arc(-20, 0, 3, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(20, 0, 3, 0, Math.PI*2); if(!this.isOpen) ctx.fill(); else ctx.stroke(); } 
                else if (this.type === 'source') { ctx.moveTo(-10, -12); ctx.lineTo(-10, 12); ctx.stroke(); ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(10, -20); ctx.lineTo(10, 20); ctx.stroke(); ctx.lineWidth = 2; ctx.font = "16px Arial"; ctx.fillStyle = "#7f8c8d"; ctx.fillText("+", 22, -15); } 
                else if (this.type === 'ac_source') { ctx.fillStyle = "#fff"; ctx.arc(0, 0, 18, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(-10, 0); ctx.bezierCurveTo(-5, -8, 0, 8, 5, 0); ctx.bezierCurveTo(8, -5, 12, 5, 10, 0); ctx.stroke(); } 
                else if (this.type === 'capacitor') { 
                    // æ¥µæ¿æç”»ä½ç½®ã®è¨ˆç®— (è·é›¢ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼å€¤ã«é€£å‹•)
                    const plateOff = Math.min(15, Math.max(2, 5 * this.cap_d));
                    
                    // â˜… å¤‰æ›´: æ¥µæ¿é«˜ã•ã®è¨ˆç®— (é¢ç©ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼å€¤ã«é€£å‹•) åŸºæº–é«˜ã•18
                    const plateH = 18 * this.cap_s;

                    // èª˜é›»ä½“æŒ¿å…¥ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ (Dielectric Insertion Animation)
                    if (this.cap_x > 0) {
                        ctx.save();
                        ctx.fillStyle = "rgba(39, 174, 96, 0.5)"; // ç·‘è‰²ã®åŠé€æ˜
                        // ä¸Šç«¯(-plateH)ã‹ã‚‰ã€é«˜ã•(2*plateH * æŒ¿å…¥ç‡) åˆ†ã ã‘æç”»
                        const h = 2 * plateH * this.cap_x;
                        ctx.fillRect(-plateOff, -plateH, plateOff * 2, h);
                        ctx.restore();
                    }
                    // æ¥µæ¿ã®æç”» (å¯å¤‰ä½ç½®ãƒ»å¯å¤‰é«˜ã•)
                    ctx.moveTo(-plateOff, -plateH); ctx.lineTo(-plateOff, plateH); 
                    ctx.moveTo(plateOff, -plateH); ctx.lineTo(plateOff, plateH); 
                    ctx.stroke(); 
                }
		// â˜…è¿½åŠ : ã‚¢ãƒ¼ã‚¹ã®æç”»
		else if (this.type === 'ground') {
		    ctx.beginPath();
		    ctx.moveTo(0, -10); ctx.lineTo(0, 0); // ç¸¦ç·š
		    ctx.moveTo(-15, 0); ctx.lineTo(15, 0); // æ¨ªç·š(å¤§)
		    ctx.moveTo(-10, 5); ctx.lineTo(10, 5); // æ¨ªç·š(ä¸­)
		    ctx.moveTo(-5, 10); ctx.lineTo(5, 10); // æ¨ªç·š(å°)
		    ctx.stroke();
		}
                else if (this.type === 'inductor') { ctx.beginPath(); const r = 6; for(let i=-2; i<=1; i++) { ctx.arc(i*10 + 5, -r, r, 0, Math.PI); } ctx.stroke(); }
		else if (this.type === 'diode' || this.type === 'led') {
		    // ä¸‰è§’å½¢ï¼ˆã‚¢ãƒãƒ¼ãƒ‰ï¼‰
		    ctx.beginPath();
		    ctx.moveTo(-15, -15); ctx.lineTo(-15, 15); ctx.lineTo(15, 0); ctx.closePath();
		    ctx.fillStyle = this.type === 'led' ? this.color : "#34495e";
		    ctx.fill(); ctx.stroke();
		    // ã‚«ã‚½ãƒ¼ãƒ‰ç·š
		    ctx.beginPath(); ctx.moveTo(15, -15); ctx.lineTo(15, 15); ctx.stroke();
    
		    // LEDã®ç™ºå…‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
		    if (this.type === 'led' && this.current > 0.001) { // 1mAä»¥ä¸Šã§ç‚¹ç¯
			ctx.save();
			ctx.shadowBlur = 15 + Math.min(this.current * 1000, 20); // é›»æµã«å¿œã˜ã¦è¼ãå¤‰åŒ–
			ctx.shadowColor = this.color;
			ctx.fillStyle = this.color;
			ctx.globalAlpha = 0.6;
			ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill();
			ctx.restore();
        
			// å…‰ã®çŸ¢å°
			ctx.beginPath();
			ctx.moveTo(5, -20); ctx.lineTo(15, -30);
			ctx.moveTo(10, -15); ctx.lineTo(20, -25);
			ctx.strokeStyle = "orange"; ctx.lineWidth = 1; ctx.stroke();
		    }
		
                }else if (['voltmeter', 'ammeter', 'galvanometer'].includes(this.type)) { ctx.fillStyle = "#ecf0f1"; ctx.beginPath(); ctx.arc(0,0, 24, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle = "#2c3e50"; ctx.font = "bold 18px Arial"; let sym = this.type === 'galvanometer' ? 'G' : (this.type === 'voltmeter' ? 'V' : 'A'); ctx.fillText(sym, 0, -5); ctx.fillStyle = "rgba(255, 255, 255, 0.9)"; ctx.fillRect(-40, 12, 80, 22); ctx.strokeStyle = "#bdc3c7"; ctx.lineWidth = 1; ctx.strokeRect(-40, 12, 80, 22); ctx.fillStyle = "#0055aa"; ctx.font = "bold 13px Consolas, monospace"; ctx.fillText(formatValue(this.type==='voltmeter'?Math.abs(this.getVoltageDiff()):Math.abs(this.current), this.type==='voltmeter'?"V":"A", true), 0, 24); }
                if (!['voltmeter', 'ammeter', 'galvanometer'].includes(this.type)) { ctx.fillStyle = "#555"; ctx.font = "12px Arial"; ctx.fillText(this.label, 0, -28); }
            }
            ctx.restore();
        }
    }

    function resize() { const c=document.getElementById('canvas-wrapper'); if(c&&c.clientWidth>0){width=canvas.width=c.clientWidth; height=canvas.height=c.clientHeight;} }
    function resizeGraph() { const c=document.getElementById('graph-wrapper'); if(c&&c.clientWidth>0){graphW=graphCanvas.width=c.clientWidth; graphH=graphCanvas.height=c.clientHeight-30;} }
    window.addEventListener('resize', () => { resize(); resizeGraph(); });

    function startSim() { isRunning = true; updateStatus(); }
    function stopSim() { isRunning = false; updateStatus(); }
    function resetSim() { isRunning = false; simTime = 0; historyData.length = 0; parts.forEach(p => { p.current = 0; p.voltageState = 0; if(p.type === 'ac_source') p.value = 0; }); nodes.forEach(n => n.voltage = 0); updateStatus(); updateProperties(); draw(); drawGraph(); }
    // --- â˜…è¿½åŠ : ã‚³ãƒé€ã‚Šæ©Ÿèƒ½ ---
    function stepSim() {
        if (isRunning) stopSim(); // å®Ÿè¡Œä¸­ãªã‚‰ä¸€æ—¦åœæ­¢
        // 1ãƒ•ãƒ¬ãƒ¼ãƒ åˆ†ã ã‘è¨ˆç®—ã‚’é€²ã‚ã‚‹
        for(let i=0; i<SUB_STEPS; i++) {
            solveCircuit();
            stepTime();
        }
        draw(); 
        drawGraph();
        if(selectedParts.length===1) updateMeasurements();
    }
    function updateStatus() { const b=document.getElementById('sim-status-badge'); b.textContent=isRunning?"å®Ÿè¡Œä¸­":"åœæ­¢ä¸­"; b.className=isRunning?"status-badge status-running":"status-badge status-stopped"; }

    function setTool(tool) { currentTool = tool; document.querySelectorAll('.sim-btn').forEach(b => b.classList.remove('active')); if(tool === 'select') document.getElementById('btn-select').classList.add('active'); if(tool === 'wire') document.getElementById('btn-wire').classList.add('active'); selectedParts = []; historyData.length = 0; updateProperties(); draw(); }
    function addPart(type) { const cx = Math.round((width?width/2:400)/GRID_SIZE)*GRID_SIZE; const cy = Math.round((height?height/2:300)/GRID_SIZE)*GRID_SIZE; const part = new Part(type, cx, cy); parts.push(part); setTool('select'); selectedParts = [part]; updateProperties(); triggerUpdate(); draw(); }
    function rotateSelected() { selectedParts.forEach(p => p.rotate()); triggerUpdate(); draw(); }
    function toggleAllSwitches() { let c = false; parts.forEach(p => { if(p.type === 'switch') { p.isOpen = !p.isOpen; c = true; } }); if(c) { triggerUpdate(); draw(); if(selectedParts.length === 1 && selectedParts[0].type === 'switch') updateProperties(); } }

    document.addEventListener('keydown', (e) => {
        if(document.getElementById('simulation-pane').classList.contains('active')) {
            if (e.key === 'r' || e.key === 'R') rotateSelected();
            if (e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
            if (e.key === ' ' || e.code === 'Space') { e.preventDefault(); const h = findPartAt(mousePos.x, mousePos.y); if (h && h.type === 'switch') { h.isOpen = !h.isOpen; triggerUpdate(); draw(); if (selectedParts.includes(h)) updateProperties(); return; } if (selectedParts.length === 1 && selectedParts[0].type === 'switch') { selectedParts[0].isOpen = !selectedParts[0].isOpen; updateProperties(); triggerUpdate(); draw(); } }
        }
    });

    function deleteSelected() {
        if (selectedParts.length > 0) {
            selectedParts.forEach(part => {
                const idx = parts.indexOf(part);
                if (idx > -1) {
                    const partNodes = part.nodes;
                    wires = wires.filter(w => !partNodes.includes(w.start) && !partNodes.includes(w.end));
                    partNodes.forEach(n => { const nIdx = nodes.indexOf(n); if (nIdx > -1) nodes.splice(nIdx, 1); });
                    parts.splice(idx, 1);
                }
            });
            selectedParts = []; historyData.length = 0; updateProperties(); triggerUpdate(); draw();
        }
    }
    function clearWires() { wires = []; parts.filter(p=>p.type==='joint').forEach(j=>{const idx=parts.indexOf(j); if(idx>-1){parts.splice(idx,1); j.nodes.forEach(n=>{const ni=nodes.indexOf(n); if(ni>-1)nodes.splice(ni,1);});}}); triggerUpdate(); draw(); }

    function getMousePos(e) { const r = canvas.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }
    function findNodeAt(x, y) { return nodes.find(n => Math.hypot(n.x - x, n.y - y) < 15); }
    function findPartAt(x, y) { return parts.find(p => Math.abs(p.x - x) < 40 && Math.abs(p.y - y) < 25); }

  // --- è¿½åŠ ã‚³ãƒ¼ãƒ‰ 1: ç·šåˆ†ã¨ã®è·é›¢è¨ˆç®—ç”¨é–¢æ•° ---
    function getDistToSegment(p, v, w) {
	const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
	if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
	let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
	t = Math.max(0, Math.min(1, t));
	return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
    }

  // --- â˜…â˜…â˜… è¿½åŠ ã‚³ãƒ¼ãƒ‰: Lå­—å‹ã®ç·šã¨ã®è·é›¢ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•° â˜…â˜…â˜… ---
    function getDistToLShapedWire(p, startNode, endNode) {
        // ãƒ¯ã‚¤ãƒ¤ãƒ¼ã®æç”»ãƒ­ã‚¸ãƒƒã‚¯: (start.x, start.y) -> (end.x, start.y) -> (end.x, end.y)
        // ã¤ã¾ã‚Šã€Œæ¨ªç§»å‹•ã€ã—ã¦ã‹ã‚‰ã€Œç¸¦ç§»å‹•ã€ã™ã‚‹2æœ¬ã®ç·šåˆ†ã¨ã—ã¦è¨ˆç®—ã™ã‚‹
        
        // è§’(Corner)ã®åº§æ¨™
        const corner = { x: endNode.x, y: startNode.y };
        
        // 1. æ¨ªã®ç·šåˆ† (Start -> Corner) ã¨ã®è·é›¢
        const dist1 = getDistToSegment(p, startNode, corner);
        
        // 2. ç¸¦ã®ç·šåˆ† (Corner -> End) ã¨ã®è·é›¢
        const dist2 = getDistToSegment(p, corner, endNode);
        
        // è¿‘ã„æ–¹ã‚’è¿”ã™
        return Math.min(dist1, dist2);
    }

    // --- â˜…â˜…â˜… ä¿®æ­£ã‚³ãƒ¼ãƒ‰: ãƒ¯ã‚¤ãƒ¤ãƒ¼ã‚’æ¢ã™é–¢æ•° (Lå­—å¯¾å¿œç‰ˆ) â˜…â˜…â˜… ---
    function findWireAt(x, y) {
        // ãƒã‚¦ã‚¹ä½ç½®(x,y)ã‹ã‚‰ ã€Œ8pxä»¥å†…ã€ ã«ã‚ã‚‹ãƒ¯ã‚¤ãƒ¤ãƒ¼ã‚’æ¢ã™ (åˆ¤å®šã‚’å°‘ã—ç”˜ãã—ã¦ã‚¯ãƒªãƒƒã‚¯ã—ã‚„ã™ãã—ã¾ã—ãŸ)
        return wires.find(w => getDistToLShapedWire({x, y}, w.start, w.end) < 8);
    }


    // ãƒ¯ã‚¤ãƒ¤ãƒ¼ã‚’åˆ†å‰²ã—ã¦Jointã‚’ä½œã‚‹é–¢æ•°
    function splitWireAndGetNode(wire, x, y) {
	// ã‚°ãƒªãƒƒãƒ‰ã«ã‚¹ãƒŠãƒƒãƒ—ã•ã›ã‚‹
	const gx = Math.round(x / GRID_SIZE) * GRID_SIZE;
	const gy = Math.round(y / GRID_SIZE) * GRID_SIZE;
	
	// æ—¢å­˜ã®ãƒ¯ã‚¤ãƒ¤ãƒ¼ã‚’å‰Šé™¤
	const idx = wires.indexOf(wire);
	if (idx > -1) wires.splice(idx, 1);
	
	// æ–°ã—ã„Jointã‚’ä½œæˆ
	const joint = new Part('joint', gx, gy);
	parts.push(joint);
	const jointNode = joint.nodes[0];
	nodes.push(jointNode);

	// å…ƒã®å§‹ç‚¹ãƒ»çµ‚ç‚¹ã¨æ–°ã—ã„Jointã‚’çµã¶ãƒ¯ã‚¤ãƒ¤ãƒ¼ã‚’2æœ¬è¿½åŠ 
	wires.push({ start: wire.start, end: jointNode });
	wires.push({ start: jointNode, end: wire.end });
	
	return jointNode;
    }

    // --- ä¿®æ­£ã‚³ãƒ¼ãƒ‰: mouseup (è‡ªå‹•æ¥ç¶šãƒ­ã‚¸ãƒƒã‚¯ã‚’è¿½åŠ ) ---
    canvas.addEventListener('mouseup', e => {
        if (currentTool === 'select') {
            if (isDragging && selectedParts.length > 0) { 
                // 1. ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—
                selectedParts.forEach(p => { p.x = Math.round(p.x / GRID_SIZE) * GRID_SIZE; p.y = Math.round(p.y / GRID_SIZE) * GRID_SIZE; }); 
                
                // â˜…â˜…â˜… è¿½åŠ : éƒ¨å“ãƒ‰ãƒ­ãƒƒãƒ—æ™‚ã®è‡ªå‹•æ¥ç¶šå‡¦ç† â˜…â˜…â˜…
                selectedParts.forEach(p => {
                    p.nodes.forEach(n => {
                        // A. ãƒ¯ã‚¤ãƒ¤ãƒ¼ã®ä¸Šã«ãƒ‰ãƒ­ãƒƒãƒ—ã—ãŸå ´åˆ
                        const wire = findWireAt(n.x, n.y); // Lå­—å¯¾å¿œç‰ˆã®åˆ¤å®šã‚’ä½¿ç”¨
                        if (wire) {
                            // ãã®ãƒ¯ã‚¤ãƒ¤ãƒ¼ãŒè‡ªåˆ†è‡ªèº«ã«ã¤ãªãŒã£ã¦ã„ãªã„ã‹ç¢ºèª
                            if (wire.start !== n && wire.end !== n) {
                                // ãƒ¯ã‚¤ãƒ¤ãƒ¼ã‚’åˆ†å‰²ã—ã¦ä¸­ç¶™ç‚¹(Joint)ã‚’ä½œã‚‹
                                const jointNode = splitWireAndGetNode(wire, n.x, n.y);
                                // éƒ¨å“ã®ç«¯å­ã¨ä¸­ç¶™ç‚¹ã‚’çµã¶ãƒ¯ã‚¤ãƒ¤ãƒ¼ã‚’è¿½åŠ 
                                wires.push({ start: n, end: jointNode });
                            }
                        }
                        
                        // B. æ—¢å­˜ã®æ¥ç¶šç‚¹(Node)ã®ä¸Šã«ãƒ‰ãƒ­ãƒƒãƒ—ã—ãŸå ´åˆ
                        const existingNode = nodes.find(en => en !== n && Math.abs(en.x - n.x) < 5 && Math.abs(en.y - n.y) < 5);
                        if (existingNode) {
                             // ã™ã§ã«æ¥ç¶šã•ã‚Œã¦ã„ãªã‘ã‚Œã°æ¥ç¶šã™ã‚‹
                             const alreadyConnected = wires.some(w => (w.start===n && w.end===existingNode) || (w.start===existingNode && w.end===n));
                             if (!alreadyConnected) {
                                 wires.push({ start: n, end: existingNode });
                             }
                        }
                    });
                });
                // â˜…â˜…â˜… è¿½åŠ ã“ã“ã¾ã§ â˜…â˜…â˜…
            } 
            else if (isBoxSelecting) {
                const x1 = Math.min(selectionBox.x, selectionBox.x + selectionBox.w), x2 = Math.max(selectionBox.x, selectionBox.x + selectionBox.w);
                const y1 = Math.min(selectionBox.y, selectionBox.y + selectionBox.h), y2 = Math.max(selectionBox.y, selectionBox.y + selectionBox.h);
                parts.forEach(p => { if (p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2 && !selectedParts.includes(p)) selectedParts.push(p); });
                updateProperties();
            }
        } else if (currentTool === 'wire' && isDragging && dragStartNode) {
            let targetNode = findNodeAt(mousePos.x, mousePos.y);
            
            // Lå­—å¯¾å¿œç‰ˆã® findWireAt ã‚’ä½¿ç”¨ã—ã¦åˆ¤å®š
            if (!targetNode) {
                const wireUnderMouse = findWireAt(mousePos.x, mousePos.y);
                if (wireUnderMouse) {
                    targetNode = splitWireAndGetNode(wireUnderMouse, mousePos.x, mousePos.y);
                }
            }

            if (!targetNode) {
                const gx = Math.round(mousePos.x/GRID_SIZE)*GRID_SIZE; const gy = Math.round(mousePos.y/GRID_SIZE)*GRID_SIZE;
                const existingJoint = parts.find(p=>p.type==='joint' && Math.abs(p.x-gx)<5 && Math.abs(p.y-gy)<5);
                if(existingJoint) targetNode = existingJoint.nodes[0];
                else { const joint = new Part('joint', gx, gy); parts.push(joint); nodes.push(joint.nodes[0]); targetNode = joint.nodes[0]; }
            }
            if (targetNode && targetNode !== dragStartNode) {
                const exists = wires.some(w => (w.start === dragStartNode && w.end === targetNode) || (w.start === targetNode && w.end === dragStartNode));
                if (!exists) wires.push({ start: dragStartNode, end: targetNode });
            }
        }
	isDragging = false; dragStartNode = null; isBoxSelecting = false; 
        triggerUpdate(); // â˜…è¿½åŠ : æ“ä½œå®Œäº†æ™‚ã«å†è¨ˆç®—ã‚’äºˆç´„
        draw();
    });
    
    canvas.addEventListener('mouseup', e => {
        if (currentTool === 'select') {
            if (isDragging && selectedParts.length > 0) { selectedParts.forEach(p => { p.x = Math.round(p.x / GRID_SIZE) * GRID_SIZE; p.y = Math.round(p.y / GRID_SIZE) * GRID_SIZE; }); } 
            else if (isBoxSelecting) {
                const x1 = Math.min(selectionBox.x, selectionBox.x + selectionBox.w), x2 = Math.max(selectionBox.x, selectionBox.x + selectionBox.w);
                const y1 = Math.min(selectionBox.y, selectionBox.y + selectionBox.h), y2 = Math.max(selectionBox.y, selectionBox.y + selectionBox.h);
                parts.forEach(p => { if (p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2 && !selectedParts.includes(p)) selectedParts.push(p); });
                updateProperties();
            }
        } else if (currentTool === 'wire' && isDragging && dragStartNode) {
            let targetNode = findNodeAt(mousePos.x, mousePos.y);
            
            // â˜… Lå­—å¯¾å¿œç‰ˆã® findWireAt ã‚’ä½¿ç”¨ã—ã¦åˆ¤å®š
            if (!targetNode) {
                const wireUnderMouse = findWireAt(mousePos.x, mousePos.y);
                if (wireUnderMouse) {
                    targetNode = splitWireAndGetNode(wireUnderMouse, mousePos.x, mousePos.y);
                }
            }

            if (!targetNode) {
                const gx = Math.round(mousePos.x/GRID_SIZE)*GRID_SIZE; const gy = Math.round(mousePos.y/GRID_SIZE)*GRID_SIZE;
                const existingJoint = parts.find(p=>p.type==='joint' && Math.abs(p.x-gx)<5 && Math.abs(p.y-gy)<5);
                if(existingJoint) targetNode = existingJoint.nodes[0];
                else { const joint = new Part('joint', gx, gy); parts.push(joint); nodes.push(joint.nodes[0]); targetNode = joint.nodes[0]; }
            }
            if (targetNode && targetNode !== dragStartNode) {
                const exists = wires.some(w => (w.start === dragStartNode && w.end === targetNode) || (w.start === targetNode && w.end === dragStartNode));
                if (!exists) wires.push({ start: dragStartNode, end: targetNode });
            }
        }
        isDragging = false; dragStartNode = null; isBoxSelecting = false; draw();
    });

    canvas.addEventListener('dblclick', e => { if (currentTool === 'select') { const p = findPartAt(getMousePos(e).x, getMousePos(e).y); if (p && p.type === 'switch') { p.isOpen = !p.isOpen; draw(); if (selectedParts.includes(p)) updateProperties(); } } });
    canvas.addEventListener('mousemove', e => {
        mousePos = getMousePos(e); hoverNode = findNodeAt(mousePos.x, mousePos.y);
        if (currentTool === 'wire') canvas.style.cursor = hoverNode ? 'crosshair' : 'default'; else canvas.style.cursor = findPartAt(mousePos.x, mousePos.y) ? 'move' : 'default';
        const dx = mousePos.x - lastMousePos.x, dy = mousePos.y - lastMousePos.y; lastMousePos = { ...mousePos };
        if (currentTool === 'select') {
            if (isDragging && selectedParts.length > 0) { selectedParts.forEach(p => { p.x += dx; p.y += dy; }); } 
            else if (isBoxSelecting) { selectionBox.w = mousePos.x - selectionBox.x; selectionBox.h = mousePos.y - selectionBox.y; }
        }
        draw();
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    function updateProperties() {
        const div = document.getElementById('prop-content');
        if (selectedParts.length === 0) { div.innerHTML = "éƒ¨å“ã‚’é¸æŠã—ã¦ãã ã•ã„"; return; } 
        else if (selectedParts.length > 1) { div.innerHTML = selectedParts.length + " å€‹ã®éƒ¨å“ã‚’é¸æŠä¸­"; return; }
        const p = selectedParts[0]; if(p.type === 'joint') { div.innerHTML = "ä¸­ç¶™ç‚¹ (é…ç·šã®çµç¯€ç‚¹)"; return; }
        let html = "";
        const mkInp = (lbl, val, id, st=1) => `<div class="prop-row">${lbl} <input type="number" id="${id}" value="${val}" step="${st}" onchange="chP('${id}', this.value)"></div>`;
        const mkSld = (val, id, mn, mx, st, lbl="èª¿æ•´") => `<div class="prop-row" style="flex-direction:column;align-items:flex-start;"><div style="display:flex;justify-content:space-between;width:100%;"><span>${lbl}</span><span style="font-size:11px;">${mn}-${mx}</span></div><input type="range" id="${id}_rg" value="${val}" min="${mn}" max="${mx}" step="${st}" oninput="chP('${id}', this.value)" style="width:100%;"></div>`;
        
        if (p.type === 'resistor') { html += mkInp("æŠµæŠ—(Î©)", p.value, "v"); html += mkSld(p.value, "v", 1, 1000, 10); }
	if (p.type === 'npn') {
	    html += mkInp("å¢—å¹…ç‡(Î²)", p.value, "v", 1);
	    html += mkSld(p.value, "v", 10, 500, 10, "ç›´æµé›»æµå¢—å¹…ç‡ hFE");
	    // ãƒˆãƒ©ãƒ³ã‚¸ã‚¹ã‚¿ç”¨ãƒ¢ãƒ‹ã‚¿ãƒ¼
	    const ib = (p.nodes[0].voltage - p.nodes[2].voltage) > 0.5 ? (p.nodes[0].voltage - p.nodes[2].voltage - 0.6)/1000 : 0; // ç°¡æ˜“è¨ˆç®—
	    // æ­£ç¢ºãªå€¤ã¯solveCircuitã§è¨ˆç®—ã•ã‚ŒãŸcurrentã‚’ä½¿ã„ãŸã„ãŒã€NPNã¯è¤‡é›‘ãªã®ã§ç°¡æ˜“è¡¨ç¤º
	    html += `<div class="box" style="font-size:11px; margin:5px 0;">
             <strong>å‹•ä½œçŠ¶æ…‹:</strong><br>
             Vbe: ${formatValue(p.nodes[0].voltage - p.nodes[2].voltage, "V")}<br>
             Vce: ${formatValue(p.nodes[1].voltage - p.nodes[2].voltage, "V")}
             </div>`;
	}
        if (p.type === 'switch') html += `<div class="prop-row"><button onclick="toggleSwitch()" style="width:100%;padding:8px;background:${p.isOpen?'#95a5a6':'#27ae60'};color:white;border:none;border-radius:4px;">${p.isOpen?'ç¾åœ¨: OFF':'ç¾åœ¨: ON'} - åˆ‡æ›¿</button></div>`;
        if (p.type === 'source') html += mkInp("é›»åœ§(V)", p.value, "v");
        if (p.type === 'ac_source') { html += mkInp("æœ€å¤§(V)", p.amplitude, "a"); html += mkInp("å‘¨æ³¢æ•°(Hz)", p.freq, "f", 0.1); }
        
        // ã‚³ãƒ³ãƒ‡ãƒ³ã‚µãƒ¼ï¼šã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼UIï¼‹ æ¼ã‚ŒæŠµæŠ—ã‚¹ã‚¤ãƒƒãƒ
        if (p.type === 'capacitor') {
            html += `<div class="prop-row" style="font-weight:bold; color:#3498db;">åˆæˆå®¹é‡: <span id="cap_val_disp">${p.value.toFixed(2)}</span> ÂµF</div>`;
	    // â˜…è¿½åŠ : æ¼ã‚ŒæŠµæŠ—ã®ON/OFFåˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³
            html += `<div class="prop-row" style="justify-content:space-between; margin-top:5px; margin-bottom:5px;">
                        <span>æ¼ã‚ŒæŠµæŠ—(Real):</span>
                        <button onclick="toggleLeakage()" style="font-size:11px; padding:4px 8px; background:${p.useLeakage?'#27ae60':'#95a5a6'}; color:white; border:none; border-radius:4px; cursor:pointer;">
                            ${p.useLeakage ? 'ON (å®‰å®š)' : 'OFF (ç†æƒ³)'}
                        </button>
                     </div>`;
	    
            html += mkSld(p.cap_s, "cap_s", 0.5, 2.0, 0.1, "æ¥µæ¿é¢ç© (S)");
            html += mkSld(p.cap_d, "cap_d", 0.1, 5.0, 0.1, "æ¥µæ¿é–“è·é›¢ (d)");
            html += mkSld(p.cap_e, "cap_e", 1.0, 10.0, 0.1, "æ¯”èª˜é›»ç‡ (Îµr)");
            html += mkSld(p.cap_x, "cap_x", 0.0, 1.0, 0.01, "èª˜é›»ä½“æŒ¿å…¥ (x)");
        }
	if (p.type === 'npn') {
            html += mkInp("å¢—å¹…ç‡(Î²)", p.value, "v", 1);
            html += mkSld(p.value, "v", 10, 500, 10, "ç›´æµé›»æµå¢—å¹…ç‡ hFE");
            
            // ç°¡æ˜“ãƒ¢ãƒ‹ã‚¿ãƒ¼è¡¨ç¤º
            const vbe = p.nodes[0].voltage - p.nodes[2].voltage;
            const vce = p.nodes[1].voltage - p.nodes[2].voltage;
            html += `<div class="box" style="font-size:11px; margin:5px 0;">
                     <strong>å‹•ä½œç‚¹:</strong><br>
                     Vbe: ${formatValue(vbe, "V")}<br>
                     Vce: ${formatValue(vce, "V")}<br>
                     Ic: ${formatValue(p.current, "A")}
                     </div>`;
        }

        if (p.type === 'inductor') html += mkInp("L(H)", p.value, "v", 0.01);
        if (['source','ac_source'].includes(p.type)) html += `<div class="prop-row">å‡ºåŠ›é›»æµ <span id="m-i" class="monitor-val">---</span></div>`;
        else if (['resistor','inductor','switch'].includes(p.type)) { html += `<div class="prop-row">é›»åœ§ <span id="m-v" class="monitor-val">---</span></div><div class="prop-row">é›»æµ <span id="m-i" class="monitor-val">---</span></div>`; }
        else if (p.type === 'capacitor') { html += `<div class="prop-row">é›»åœ§ <span id="m-v" class="monitor-val">---</span></div><div class="prop-row">é›»è· <span id="m-q" class="monitor-val monitor-val-q">---</span></div>`; }
        else if (['voltmeter','ammeter','galvanometer'].includes(p.type)) html += `<div class="prop-row">å€¤ <span id="m-val" class="monitor-val">---</span></div>`;
        div.innerHTML = html; updateMeasurements();
    }
    
    function chP(k, v) { 
        if(selectedParts.length!==1)return; 
        const p=selectedParts[0], n=parseFloat(v); 
        if(isNaN(n))return; 

        // å…±é€šãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®æ›´æ–°
        if(k==='v'){
            p.value=n; 
            if(p.type==='resistor')p.label=n+"Î©"; 
            if(p.type==='source')p.label=n+"V"; 
            if(p.type==='capacitor')p.label=n.toFixed(1)+"ÂµF"; 
            if(p.type==='inductor')p.label=n+"H"; 
            const s=document.getElementById('v_rg'), b=document.getElementById('v'); 
            if(s&&b){s.value=n;b.value=n;}
        }
        else if(k==='a'){p.amplitude=n; p.label=n+"V\n"+p.freq+"Hz";} 
        else if(k==='f'){p.freq=n; p.label=p.amplitude+"V\n"+n+"Hz";} 
        
        // ã‚³ãƒ³ãƒ‡ãƒ³ã‚µãƒ¼ç‰©ç†ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ›´æ–°ã¨å†è¨ˆç®—
        else if(['cap_d', 'cap_e', 'cap_x', 'cap_s'].includes(k)) {
            // é‡è¦: é›»è·ä¿å­˜å‰‡ (Q = CV) ã«åŸºã¥ãéæ¸¡ç¾è±¡ã®è¨ˆç®—
            const oldC = p.value; 
            if (k === 'cap_d') p.cap_d = n;
            if (k === 'cap_e') p.cap_e = n;
            if (k === 'cap_x') p.cap_x = n;
            if (k === 'cap_s') p.cap_s = n;
            
            // â˜… é™é›»å®¹é‡ã®è¨ˆç®—: C = (base_C * S / d) * ((1-x) + e*x)
            const epsilon_eff = (1 - p.cap_x) + (p.cap_e * p.cap_x);
            p.value = (p.base_C * p.cap_s / p.cap_d) * epsilon_eff;
            p.label = p.value.toFixed(1) + "ÂµF";
            
            // é›»åœ§çŠ¶æ…‹ã®æ›´æ–° (é›»è·ä¿å­˜å‰‡ã®é©ç”¨)
            if (p.value > 1e-12 && oldC > 1e-12) {
                p.voltageState = p.voltageState * (oldC / p.value);
            }
            const disp = document.getElementById('cap_val_disp');
            if(disp) disp.innerText = p.value.toFixed(2);
	    triggerUpdate();
            draw();
        }
	// â˜…â˜…â˜… è¿½åŠ : é–¢æ•°ã®æœ€å¾Œã«ã“ã‚Œã‚’è¿½åŠ ã—ã¦ãã ã•ã„ â˜…â˜…â˜…
        triggerUpdate(); 
        draw();
    }

    function toggleSwitch() { if(selectedParts.length===1 && selectedParts[0].type==='switch'){selectedParts[0].isOpen=!selectedParts[0].isOpen; updateProperties(); draw();} }
    // â˜…è¿½åŠ : æ¼ã‚ŒæŠµæŠ—åˆ‡ã‚Šæ›¿ãˆç”¨é–¢æ•°
    function toggleLeakage() {
        if(selectedParts.length===1 && selectedParts[0].type==='capacitor'){
            selectedParts[0].useLeakage = !selectedParts[0].useLeakage;
            // çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆã—ãªã„ã¨æ€¥æ¿€ãªé›»åœ§å¤‰å‹•ãŒèµ·ãã‚‹ã“ã¨ãŒã‚ã‚‹ãŸã‚ã€é›»åœ§çŠ¶æ…‹ã‚’å°‘ã—ç·©å’Œã™ã‚‹
            selectedParts[0].voltageState *= 0.99; 
            updateProperties();
	    triggerUpdate();
            draw();
        }
    }
    function updateMeasurements() {
        if(selectedParts.length!==1)return; const p=selectedParts[0];
        const setT = (id, v, u) => { const e=document.getElementById(id); if(e)e.innerText=formatValue(v, u, true); };
        if(['source','ac_source'].includes(p.type)) setT('m-i', p.current, "A");
        else if(['resistor','inductor','switch'].includes(p.type)) { setT('m-v', p.getVoltageDiff(), "V"); setT('m-i', p.current, "A"); }
        else if(p.type==='capacitor') { setT('m-v', p.getVoltageDiff(), "V"); setT('m-q', p.getCharge(), "C"); }
        else if(['voltmeter','ammeter','galvanometer'].includes(p.type)) setT('m-val', p.type==='voltmeter'?p.getVoltageDiff():p.current, p.type==='voltmeter'?"V":"A");
    }

  // --- â˜…â˜…â˜… ç‰©ç†ã‚¨ãƒ³ã‚¸ãƒ³ (ã‚³ãƒ³ãƒ‘ãƒ‹ã‚ªãƒ³ãƒ¢ãƒ‡ãƒ«ã«ã‚ˆã‚‹å³å¯†è§£æ³•) â˜…â˜…â˜… ---
  function solveCircuit() {
        const nets = []; nodes.forEach(n => n.netId = -1);
        
        function traceNet(n, id) { 
            n.netId=id; 
            if(!nets[id]) { nets[id]={nodes:[], voltage:n.voltage, fixed:false}; }
            nets[id].nodes.push(n); 
            wires.forEach(w=>{if(w.start===n&&w.end.netId===-1)traceNet(w.end,id);if(w.end===n&&w.start.netId===-1)traceNet(w.start,id);}); 
        }
        // 1. ãƒãƒƒãƒˆãƒªã‚¹ãƒˆä½œæˆå¾Œã€ã‚¢ãƒ¼ã‚¹ã®å‡¦ç†ã‚’è¿½åŠ 
        let c=0; nodes.forEach(n=>{if(n.netId===-1){traceNet(n,c);c++;}});
        let g=false;
        // â˜…å¤‰æ›´: ã‚¢ãƒ¼ã‚¹(ground)ãŒã¤ãªãŒã£ã¦ã„ã‚‹ãƒãƒƒãƒˆã‚’å„ªå…ˆçš„ã«0Vå›ºå®šã«ã™ã‚‹
        parts.filter(p => p.type === 'ground').forEach(gp => {
            const n = nets[gp.nodes[0].netId];
            if (n) { n.fixed = true; n.voltage = 0; g = true; }
        });
        // ã‚¢ãƒ¼ã‚¹ãŒãªã„å ´åˆã¯ã€å¾“æ¥ã©ãŠã‚Šé›»æºã®ãƒã‚¤ãƒŠã‚¹å´ãªã©ã‚’åŸºæº–ã«ã™ã‚‹
        if (!g) {
            parts.filter(p=>['source','ac_source'].includes(p.type)).forEach(s=>{if(!g){const n=nets[s.nodes[0].netId]; if(n){n.fixed=true;n.voltage=0;g=true;}}});
        }
        // ãã‚Œã§ã‚‚æ±ºã¾ã‚‰ãªã‘ã‚Œã°ãƒãƒƒãƒˆ0ã‚’åŸºæº–ã«ã™ã‚‹
        if(!g&&nets.length>0&&nets[0]){nets[0].fixed=true;nets[0].voltage=0;}
        
        for(let k=0;k<ITERATIONS;k++){
            nets.forEach(net=>{
                if(!net||net.fixed)return; let num=0,den=G_LEAK;
                net.nodes.forEach(node=>{
                    const p=node.parentPart; if(p.type==='joint')return;
                    
                    // --- NPN Transistor Special Handling ---
                    if (p.type === 'npn') {
                        const v_be = p.nodes[0].voltage - p.nodes[2].voltage;
                        const v_ce = p.nodes[1].voltage - p.nodes[2].voltage;
                        const idx = p.nodes.indexOf(node);
                        
                        // Base Logic
                        if (idx === 0) { 
                            const eNet = nets[p.nodes[2].netId];
                            if (eNet) {
                                let r = (v_be > 0.6) ? 500 : 1e7; 
                                let g = 1.0/r; num += (eNet.voltage + 0.6) * g; den += g;
                            }
                        }
                        // Collector Logic
                        else if (idx === 1) { 
                            const eNet = nets[p.nodes[2].netId];
                            if (eNet) {
                                let r = 1e8;
                                if (v_be > 0.6) {
                                    // Amplification model: Ic = Beta * Ib
                                    let ib = (v_be - 0.6) / 500;
                                    let ic = ib * p.value;
                                    // Saturation model
                                    if (v_ce < 0.2) r = 5; 
                                    else if (ic > 0) r = Math.max(5, v_ce / ic);
                                }
                                let g = 1.0/r; num += eNet.voltage * g; den += g;
                            }
                        }
                        // Emitter Logic
                        else if (idx === 2) {
                            // From Base
                            const bNet = nets[p.nodes[0].netId];
                            if (bNet) {
                                let r = (v_be > 0.6) ? 500 : 1e7;
                                let g = 1.0/r; num += (bNet.voltage - 0.6) * g; den += g;
                            }
                            // From Collector
                            const cNet = nets[p.nodes[1].netId];
                            if (cNet) {
                                let r = 1e8;
                                if (v_be > 0.6) {
                                    let ib = (v_be - 0.6) / 500;
                                    let ic = ib * p.value;
                                    if (v_ce < 0.2) r = 5;
                                    else if (ic > 0) r = Math.max(5, v_ce / ic);
                                }
                                let g = 1.0/r; num += cNet.voltage * g; den += g;
                            }
                        }
                        return; // NPN done
                    }

                    // --- Standard 2-Node Components ---
                    const oNode=(p.nodes[0]===node)?p.nodes[1]:p.nodes[0]; 
                    const oNet=nets[oNode.netId]; if(!oNet)return;
                    
                    let r=1e9, v_off=0;
                    
                    if(['source','ac_source'].includes(p.type)){ r=INTERNAL_R_SRC; v_off=(p.nodes[1]===node)?p.value:-p.value; }
                    else if(p.type==='switch') r=p.isOpen?R_SWITCH_OPEN:R_SWITCH_CLOSED;
                    else if(['resistor','voltmeter'].includes(p.type)) r=p.value;
                    else if(['ammeter','galvanometer'].includes(p.type)) r=INTERNAL_R_AMMETER;
		    // â˜…å¤‰æ›´: ã‚³ãƒ³ãƒ‡ãƒ³ã‚µãƒ¼ã®å‡¦ç†
                    else if(p.type==='capacitor'){ 
                        // ã‚³ãƒ³ãƒ‘ãƒ‹ã‚ªãƒ³ãƒ¢ãƒ‡ãƒ«
                        r = dt/(p.value*1e-6); 
                        v_off = (p.nodes[1]===node) ? -p.voltageState : p.voltageState; 
                        
                        // æ¼ã‚ŒæŠµæŠ— (Leakage Resistance) 
                        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã€ŒONã€ã«ã—ã¦ã„ã‚‹å ´åˆã®ã¿é©ç”¨ã™ã‚‹
                        if (p.useLeakage) {
                            const R_LEAK = 1e6; // 1MÎ©
                            const g_leak = 1.0 / R_LEAK;
                            num += oNet.voltage * g_leak;
                            den += g_leak;
                        }
                    }
                    else if(p.type==='inductor'){ r = p.value/dt; const v_eq = r * p.current; v_off = (p.nodes[1] === node) ? v_eq : -v_eq; }
                    
                    // --- Diode / LED Logic ---
                    else if(p.type === 'diode' || p.type === 'led') {
                        const vf = p.type==='led' ? 1.8 : 0.6;
                        // Determine bias based on current voltage estimate
                        const v_anode = p.nodes[0].voltage;
                        const v_cathode = p.nodes[1].voltage;
                        const fw = (v_anode - v_cathode) > vf;
                        
                        if(fw) { r = 5; v_off = (p.nodes[1] === node) ? vf : -vf; } // ON
                        else { r = 1e8; v_off = 0; } // OFF
                    }

                    const g=1.0/r; num+=(oNet.voltage+v_off)*g; den+=g;
                });
                if(den>0)net.voltage=num/den;
            });
        }
        nets.forEach(net=>{if(net)net.nodes.forEach(n=>n.voltage=net.voltage);});
        
        // --- Calculate Currents for Components ---
        parts.forEach(p => {
            if (p.type === 'joint') return;

            // NPN Transistor Current Calculation
            if (p.type === 'npn') {
                const v_be = p.nodes[0].voltage - p.nodes[2].voltage;
                const v_ce = p.nodes[1].voltage - p.nodes[2].voltage;
                let ic = 0;
                
                // ç°¡æ˜“çš„ãªå¢—å¹…ãƒ¢ãƒ‡ãƒ«
                if (v_be > 0.6) {
                     // ãƒ™ãƒ¼ã‚¹é›»æµã®æ¦‚ç®—ï¼ˆå†…éƒ¨æŠµæŠ—ã‚’ä»®å®šï¼‰
                     const ib = (v_be - 0.6) / 500; 
                     ic = ib * p.value; 
                     
                     // é£½å’Œé ˜åŸŸï¼ˆSaturationï¼‰ã®åˆ¶é™
                     if (v_ce < 0.2) {
                         ic = v_ce / 5; // é£½å’Œæ™‚ã®æŠµæŠ—ã‚’å°ã•ãä»®å®š
                     } else if (ic * 5 > v_ce) { 
                         // è² è·ç·šã¨ã®äº¤ç‚¹ã‚’ç°¡æ˜“çš„ã«è¡¨ç¾ï¼ˆå®Œå…¨ã«æ­£ç¢ºã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã—ã¦ã¯å‹•ä½œã—ã¾ã™ï¼‰
                         // ic = ic; 
                     }
                }
                p.current = ic; // ã‚³ãƒ¬ã‚¯ã‚¿é›»æµã‚’ãƒ¡ã‚¤ãƒ³ã®é›»æµã¨ã—ã¦è¡¨ç¤º
                return;
            }

            const vd = p.getVoltageDiff();
            
            if (p.type === 'capacitor') {
                // I = C * dV/dt => (V_current - V_state) / R_eq
                const req = dt / (p.value * 1e-6);
                if (req > 1e-9) {
                     p.current = (vd - p.voltageState) / req;
                } else {
                     p.current = 0;
                }
            }
            else if (p.type === 'inductor') {
                // ã‚³ã‚¤ãƒ«ã®é›»æµã¯ stepTime ã§ç©åˆ†è¨ˆç®—ã•ã‚Œã‚‹ãŸã‚ã€ã“ã“ã§ã¯è£œæ­£ã—ãªã„
                // ãŸã ã—è¡¨ç¤ºç”¨ã«ç›´è¿‘ã®å€¤ã‚’ä¿æŒ
            }
            else if (p.type === 'switch') {
                p.current = vd / (p.isOpen ? R_SWITCH_OPEN : R_SWITCH_CLOSED);
            }
            else if (['source', 'ac_source'].includes(p.type)) {
                // é›»æºé›»æµã®é€†ç®—: (V_source + V_node_diff) / R_internal
                // â€»ã“ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã®ãƒ¢ãƒ‡ãƒ«ã§ã¯é›»æºã¯å†…éƒ¨æŠµæŠ—ã‚’æŒã¤é›»åœ§æºã¨ã—ã¦æ‰±ã‚ã‚Œã¦ã„ã¾ã™
                p.current = (p.value - vd) / INTERNAL_R_SRC; // å‘ãã«æ³¨æ„: èµ·é›»åŠ›æ–¹å‘ã‚’æ­£ã¨ã™ã‚‹
            }
            else if (p.type === 'diode' || p.type === 'led') {
                const vf = p.type === 'led' ? 1.8 : 0.6;
                if (vd > vf) {
                    p.current = (vd - vf) / 5; // ONæ™‚ã®å‹•çš„æŠµæŠ—
                } else {
                    p.current = vd / 1e8; // OFFæ™‚ã®æ¼ã‚Œé›»æµ
                }
            }
            else {
                // æŠµæŠ—ã€è¨ˆæ¸¬å™¨ãªã©
                const r = (p.type === 'ammeter' || p.type === 'galvanometer') ? INTERNAL_R_AMMETER : p.value;
                p.current = vd / r;
            }
        });
  }

    function stepTime() {
        simTime+=dt; animationOffset+=dt;
        parts.forEach(p=>{if(p.type==='ac_source')p.value=p.amplitude*Math.sin(2*Math.PI*p.freq*simTime);});
        parts.forEach(p=>{
            const vd=p.getVoltageDiff();
            if(p.type==='capacitor')p.voltageState+=(p.current/(p.value*1e-6))*dt;
            else if(p.type==='inductor'){
                p.current+=(vd/p.value)*dt; 
                //p.current*=0.9995;
            }
        });
        if(selectedParts.length===1 && selectedParts[0].type!=='joint'){
            const p=selectedParts[0]; historyData.push({v:p.getVoltageDiff(), i:p.current, q:p.getCharge()});
            if(historyData.length>MAX_HISTORY)historyData.shift();
        }
    }

    // --- æç”»é–¢æ•° (æ›´æ–°ç‰ˆ: æ¥ç¶šãƒã‚§ãƒƒã‚¯å¯¾å¿œ) ---
    function draw() {
        if(width===0||height===0)return; ctx.clearRect(0,0,width,height);
        
        // ãƒ¯ã‚¤ãƒ¤ãƒ¼ã®æç”»
        wires.forEach(w=>{ 
            ctx.beginPath(); 
            ctx.moveTo(w.start.x, w.start.y); 
            ctx.lineTo(w.end.x, w.start.y); 
            ctx.lineTo(w.end.x, w.end.y); 
            
            // æ¥ç¶šãƒã‚§ãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰ãªã‚‰è‰²ã‚’å¤‰ãˆã‚‹
            if (isNetViewMode && w.start.netId !== -1) {
                ctx.strokeStyle = getNetColor(w.start.netId);
                ctx.lineWidth = 4; ctx.globalAlpha = 0.8;
            } else {
                ctx.strokeStyle = "#27ae60"; ctx.lineWidth = 2; ctx.globalAlpha = 1.0;
            }
            ctx.stroke(); ctx.globalAlpha = 1.0;
        });

        // æ¥ç¶šç‚¹ã®æç”»
        wires.forEach(w=>{ 
            if (isNetViewMode && w.start.netId !== -1) ctx.fillStyle = getNetColor(w.start.netId);
            else ctx.fillStyle = "#27ae60";
            ctx.beginPath(); ctx.arc(w.start.x,w.start.y,3,0,2*Math.PI); ctx.fill(); 
            ctx.beginPath(); ctx.arc(w.end.x,w.end.y,3,0,2*Math.PI); ctx.fill(); 
            ctx.beginPath(); ctx.arc(w.end.x, w.start.y, 2, 0, 2*Math.PI); ctx.fill(); 
        });

        // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ãƒ¯ã‚¤ãƒ¤ãƒ¼æç”»
        if(currentTool==='wire'&&isDragging&&dragStartNode){
            ctx.strokeStyle="#2ecc71"; ctx.lineWidth=2; ctx.setLineDash([5,5]); ctx.beginPath();
            ctx.moveTo(dragStartNode.x, dragStartNode.y); const tx = mousePos.x, ty = mousePos.y; ctx.lineTo(tx, dragStartNode.y); ctx.lineTo(tx, ty); 
            ctx.stroke(); ctx.setLineDash([]);
            const gx = Math.round(mousePos.x/GRID_SIZE)*GRID_SIZE; const gy = Math.round(mousePos.y/GRID_SIZE)*GRID_SIZE;
            ctx.fillStyle="rgba(46, 204, 113, 0.5)"; ctx.beginPath(); ctx.arc(gx, gy, 6, 0, 2*Math.PI); ctx.fill();
        }
        
        // ç¯„å›²é¸æŠãƒœãƒƒã‚¯ã‚¹
        if(currentTool==='select'&&isBoxSelecting){ ctx.fillStyle="rgba(52,152,219,0.2)"; ctx.strokeStyle="#3498db"; ctx.lineWidth=1; ctx.setLineDash([3,3]); ctx.fillRect(selectionBox.x,selectionBox.y,selectionBox.w,selectionBox.h); ctx.strokeRect(selectionBox.x,selectionBox.y,selectionBox.w,selectionBox.h); ctx.setLineDash([]); }
        
        // éƒ¨å“ã®æç”»
        parts.forEach(p=>p.draw(ctx));
        
        // ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ„ãƒ¼ãƒ«æ™‚ã®ãƒ›ãƒãƒ¼è¡¨ç¤º
        if(currentTool==='wire'&&hoverNode){ctx.beginPath();ctx.fillStyle="#e74c3c";ctx.arc(hoverNode.x,hoverNode.y,6,0,2*Math.PI);ctx.fill();}
    }

    function deleteSelected() {
        if (selectedParts.length > 0) {
            selectedParts.forEach(part => {
                const idx = parts.indexOf(part);
                if (idx > -1) {
                    const partNodes = part.nodes;
                    wires = wires.filter(w => !partNodes.includes(w.start) && !partNodes.includes(w.end));
                    partNodes.forEach(n => { const nIdx = nodes.indexOf(n); if (nIdx > -1) nodes.splice(nIdx, 1); });
                    parts.splice(idx, 1);
                }
            });
            selectedParts = []; historyData.length = 0; updateProperties(); triggerUpdate(); draw();
        }
    }
    function clearWires() { wires = []; parts.filter(p=>p.type==='joint').forEach(j=>{const idx=parts.indexOf(j); if(idx>-1){parts.splice(idx,1); j.nodes.forEach(n=>{const ni=nodes.indexOf(n); if(ni>-1)nodes.splice(ni,1);});}}); triggerUpdate(); draw(); }

    function getMousePos(e) { const r = canvas.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }
    function findNodeAt(x, y) { return nodes.find(n => Math.hypot(n.x - x, n.y - y) < 15); }
    function findPartAt(x, y) { return parts.find(p => Math.abs(p.x - x) < 40 && Math.abs(p.y - y) < 25); }

    // --- è¨ˆç®—ãƒ»åˆ¤å®šç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼ (Lå­—é…ç·šå¯¾å¿œ) ---
    function getDistToSegment(p, v, w) {
        const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
        if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
        let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
    }

    function getDistToLShapedWire(p, startNode, endNode) {
        const corner = { x: endNode.x, y: startNode.y };
        const dist1 = getDistToSegment(p, startNode, corner);
        const dist2 = getDistToSegment(p, corner, endNode);
        return Math.min(dist1, dist2);
    }

    function findWireAt(x, y) {
        // åˆ¤å®šã‚’å°‘ã—ç”˜ã(8px)ã—ã¦ã‚¯ãƒªãƒƒã‚¯ã—ã‚„ã™ã
        return wires.find(w => getDistToLShapedWire({x, y}, w.start, w.end) < 8);
    }

    function splitWireAndGetNode(wire, x, y) {
        const gx = Math.round(x / GRID_SIZE) * GRID_SIZE;
        const gy = Math.round(y / GRID_SIZE) * GRID_SIZE;
        const idx = wires.indexOf(wire);
        if (idx > -1) wires.splice(idx, 1);
        const joint = new Part('joint', gx, gy);
        parts.push(joint);
        const jointNode = joint.nodes[0];
        nodes.push(jointNode);
        wires.push({ start: wire.start, end: jointNode });
        wires.push({ start: jointNode, end: wire.end });
        return jointNode;
    }

    // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ (é‡è¤‡ã‚’è§£æ¶ˆã—çµ±åˆ) ---
    canvas.addEventListener('mousedown', e => {
        mousePos = getMousePos(e); lastMousePos = { ...mousePos }; mouseDownPos = { ...mousePos }; // â˜…è¿½åŠ : æŠ¼ã—å§‹ã‚ãŸä½ç½®ã‚’è¨˜æ†¶
        if (e.button === 2) { isDragging = false; dragStartNode = null; isBoxSelecting = false; selectedParts = []; historyData.length = 0; updateProperties(); draw(); return; }
        
        if (currentTool === 'select') {
            const part = findPartAt(mousePos.x, mousePos.y);
            if (part) {
                if (e.shiftKey) { const idx = selectedParts.indexOf(part); if (idx > -1) selectedParts.splice(idx, 1); else selectedParts.push(part); } 
                else { if (!selectedParts.includes(part)) { selectedParts = [part]; historyData.length = 0; } }
                isDragging = true;
            } else { if (!e.shiftKey) { selectedParts = []; historyData.length = 0; } isBoxSelecting = true; selectionBox = { x: mousePos.x, y: mousePos.y, w: 0, h: 0 }; }
            updateProperties();
        } else if (currentTool === 'wire') {
            let node = findNodeAt(mousePos.x, mousePos.y);
            
            // ãƒãƒ¼ãƒ‰ãŒç„¡ã„å ´åˆã€ãƒ¯ã‚¤ãƒ¤ãƒ¼ã®ä¸Šã‹ãƒã‚§ãƒƒã‚¯
            if (!node) {
                const wireUnderMouse = findWireAt(mousePos.x, mousePos.y);
                if (wireUnderMouse) {
                    // ãƒ¯ã‚¤ãƒ¤ãƒ¼ä¸Šãªã‚‰åˆ†å‰²ã—ã¦æ¥ç¶šç‚¹ã«ã™ã‚‹
                    node = splitWireAndGetNode(wireUnderMouse, mousePos.x, mousePos.y);
                }
            }
            
            if (node) { dragStartNode = node; isDragging = true; }
            else { 
                const gx = Math.round(mousePos.x/GRID_SIZE)*GRID_SIZE; const gy = Math.round(mousePos.y/GRID_SIZE)*GRID_SIZE; 
                const joint = new Part('joint', gx, gy); parts.push(joint); nodes.push(joint.nodes[0]); dragStartNode = joint.nodes[0]; isDragging = true; draw(); 
            }
        }
        draw();
    });
    
    canvas.addEventListener('mouseup', e => {
        // â˜…è¿½åŠ : ã‚¯ãƒªãƒƒã‚¯åˆ¤å®š (ãƒã‚¦ã‚¹ãŒã»ã¨ã‚“ã©å‹•ã„ã¦ã„ãªã‘ã‚Œã°ã‚¯ãƒªãƒƒã‚¯ã¨ã¿ãªã™)
        const dist = Math.hypot(mousePos.x - mouseDownPos.x, mousePos.y - mouseDownPos.y);
        if (dist < 3 && currentTool === 'select') {
            const p = findPartAt(mousePos.x, mousePos.y);
            // ã‚¹ã‚¤ãƒƒãƒãªã‚‰åˆ‡ã‚Šæ›¿ãˆ
            if (p && p.type === 'switch') {
                p.isOpen = !p.isOpen;
                updateProperties(); // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£è¡¨ç¤ºã‚‚æ›´æ–°
                draw();
            }
        }
        if (currentTool === 'select') {
            if (isDragging && selectedParts.length > 0) { 
                // 1. ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—
                selectedParts.forEach(p => { p.x = Math.round(p.x / GRID_SIZE) * GRID_SIZE; p.y = Math.round(p.y / GRID_SIZE) * GRID_SIZE; }); 
                
                // 2. éƒ¨å“ãƒ‰ãƒ­ãƒƒãƒ—æ™‚ã®è‡ªå‹•æ¥ç¶šå‡¦ç†
                selectedParts.forEach(p => {
                    p.nodes.forEach(n => {
                        // A. ãƒ¯ã‚¤ãƒ¤ãƒ¼ã®ä¸Šã«ãƒ‰ãƒ­ãƒƒãƒ—ã—ãŸå ´åˆ
                        const wire = findWireAt(n.x, n.y); 
                        if (wire) {
                            if (wire.start !== n && wire.end !== n) {
                                const jointNode = splitWireAndGetNode(wire, n.x, n.y);
                                wires.push({ start: n, end: jointNode });
                            }
                        }
                        
                        // B. æ—¢å­˜ã®æ¥ç¶šç‚¹(Node)ã®ä¸Šã«ãƒ‰ãƒ­ãƒƒãƒ—ã—ãŸå ´åˆ
                        const existingNode = nodes.find(en => en !== n && Math.hypot(en.x - n.x, en.y - n.y) < 5);
                        if (existingNode) {
                             const alreadyConnected = wires.some(w => (w.start===n && w.end===existingNode) || (w.start===existingNode && w.end===n));
                             if (!alreadyConnected) wires.push({ start: n, end: existingNode });
                        }
                    });
                });
            } 
            else if (isBoxSelecting) {
                const x1 = Math.min(selectionBox.x, selectionBox.x + selectionBox.w), x2 = Math.max(selectionBox.x, selectionBox.x + selectionBox.w);
                const y1 = Math.min(selectionBox.y, selectionBox.y + selectionBox.h), y2 = Math.max(selectionBox.y, selectionBox.y + selectionBox.h);
                parts.forEach(p => { if (p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2 && !selectedParts.includes(p)) selectedParts.push(p); });
                updateProperties();
            }
        } else if (currentTool === 'wire' && isDragging && dragStartNode) {
            let targetNode = findNodeAt(mousePos.x, mousePos.y);
            
            // ãƒ‰ãƒ­ãƒƒãƒ—å…ˆã«ãƒãƒ¼ãƒ‰ãŒç„¡ã„å ´åˆã€ãƒ¯ã‚¤ãƒ¤ãƒ¼ã®ä¸Šã‹ãƒã‚§ãƒƒã‚¯
            if (!targetNode) {
                const wireUnderMouse = findWireAt(mousePos.x, mousePos.y);
                if (wireUnderMouse) {
                    targetNode = splitWireAndGetNode(wireUnderMouse, mousePos.x, mousePos.y);
                }
            }

            if (!targetNode) {
                const gx = Math.round(mousePos.x/GRID_SIZE)*GRID_SIZE; const gy = Math.round(mousePos.y/GRID_SIZE)*GRID_SIZE;
                const existingJoint = parts.find(p=>p.type==='joint' && Math.abs(p.x-gx)<5 && Math.abs(p.y-gy)<5);
                if(existingJoint) targetNode = existingJoint.nodes[0];
                else { const joint = new Part('joint', gx, gy); parts.push(joint); nodes.push(joint.nodes[0]); targetNode = joint.nodes[0]; }
            }
            if (targetNode && targetNode !== dragStartNode) {
                const exists = wires.some(w => (w.start === dragStartNode && w.end === targetNode) || (w.start === targetNode && w.end === dragStartNode));
                if (!exists) wires.push({ start: dragStartNode, end: targetNode });
            }
        }
        isDragging = false; dragStartNode = null; isBoxSelecting = false; draw();
    });

    canvas.addEventListener('dblclick', e => { if (currentTool === 'select') { const p = findPartAt(getMousePos(e).x, getMousePos(e).y); if (p && p.type === 'switch') { p.isOpen = !p.isOpen; triggerUpdate(); draw(); if (selectedParts.includes(p)) updateProperties(); } } });
    canvas.addEventListener('mousemove', e => {
        mousePos = getMousePos(e); hoverNode = findNodeAt(mousePos.x, mousePos.y);
        if (currentTool === 'wire') canvas.style.cursor = hoverNode ? 'crosshair' : 'default'; else canvas.style.cursor = findPartAt(mousePos.x, mousePos.y) ? 'move' : 'default';
        const dx = mousePos.x - lastMousePos.x, dy = mousePos.y - lastMousePos.y; lastMousePos = { ...mousePos };
        if (currentTool === 'select') {
            if (isDragging && selectedParts.length > 0) { selectedParts.forEach(p => { p.x += dx; p.y += dy; }); } 
            else if (isBoxSelecting) { selectionBox.w = mousePos.x - selectionBox.x; selectionBox.h = mousePos.y - selectionBox.y; }
        }
        draw();
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    function drawGraph() {
        if(selectedParts.length!==1 || selectedParts[0].type==='joint'){gCtx.clearRect(0,0,graphW,graphH); gCtx.fillStyle="#aaa"; gCtx.font="12px sans-serif"; gCtx.textAlign="center"; gCtx.fillText("ç´ å­ã‚’é¸æŠ (ä¸­ç¶™ç‚¹ä»¥å¤–)",graphW/2,graphH/2); return;}
        gCtx.clearRect(0,0,graphW,graphH); const p=selectedParts[0];
        const PT=20, PB=20, PL=5, PR=5, DH=graphH-PT-PB, CY=PT+DH/2;
        let mv=0.1; historyData.forEach(d=>{const a=Math.abs(d.v); if(a>mv)mv=a;}); mv*=1.1; const sv=(DH/2)/mv;
        let m2=1e-9; const isC=p.type==='capacitor', u2=isC?"C":"A";
        historyData.forEach(d=>{const v=isC?d.q:d.i, a=Math.abs(v); if(a>m2)m2=a;}); m2*=1.1; const s2=(DH/2)/m2;
        gCtx.strokeStyle="#eee"; gCtx.lineWidth=1; gCtx.setLineDash([5,5]); gCtx.beginPath(); gCtx.moveTo(0,CY);gCtx.lineTo(graphW,CY); gCtx.moveTo(0,PT);gCtx.lineTo(graphW,PT); gCtx.moveTo(0,graphH-PB);gCtx.lineTo(graphW,graphH-PB); gCtx.stroke(); gCtx.setLineDash([]);
        gCtx.strokeStyle="#ccc"; gCtx.beginPath(); gCtx.moveTo(0,CY);gCtx.lineTo(graphW,CY); gCtx.stroke();
        gCtx.font="11px sans-serif"; gCtx.textAlign="left"; gCtx.fillStyle="#2980b9"; gCtx.fillText("+"+formatValue(mv,"V",true),PL,PT-5); gCtx.fillText("-"+formatValue(mv,"V",true),PL,graphH-5);
        let cv=historyData.length>0?historyData[historyData.length-1].v:p.getVoltageDiff(); gCtx.font="bold 12px sans-serif"; gCtx.fillText("V: "+formatValue(cv,"V",false),PL+80,PT-5);
        gCtx.textAlign="right"; gCtx.fillStyle=isC?"#27ae60":"#e67e22"; gCtx.font="11px sans-serif"; gCtx.fillText("+"+formatValue(m2,u2,true),graphW-PR,PT-5); gCtx.fillText("-"+formatValue(m2,u2,true),graphW-PR,graphH-5);
        let c2=0; if(historyData.length>0)c2=isC?historyData[historyData.length-1].q:historyData[historyData.length-1].i; else c2=isC?p.getCharge():p.current;
        gCtx.font="bold 12px sans-serif"; gCtx.fillText((isC?"Q: ":"I: ")+formatValue(c2,u2,false),graphW-PR-80,PT-5);
        if(historyData.length>1){
            const plt=(fn,sc,cl)=>{gCtx.strokeStyle=cl; gCtx.lineWidth=2; gCtx.beginPath(); historyData.forEach((d,i)=>{const x=(i/(MAX_HISTORY-1))*graphW, y=CY-(fn(d)*sc); if(i===0)gCtx.moveTo(x,y); else gCtx.lineTo(x,y);}); gCtx.stroke();}
            plt(d=>d.v,sv,"rgba(41,128,185,0.7)"); if(isC)plt(d=>d.q,s2,"rgba(39,174,96,0.9)"); else plt(d=>d.i,s2,"rgba(230,126,34,0.9)");
        }
    }

    const SUB_STEPS = 10; // â˜…ã‚µãƒ–ã‚¹ãƒ†ãƒƒãƒ—æ•°ã‚’å®šç¾©

    function loop() {
        if(document.getElementById('simulation-pane').classList.contains('active')) {
            // â˜…ã‚µãƒ–ã‚¹ãƒ†ãƒƒãƒ—ã®ãƒ«ãƒ¼ãƒ—ã‚’è¿½åŠ 
            if (isRunning) {
                for(let i=0; i<SUB_STEPS; i++) {
                    solveCircuit();
                    stepTime();
                }
            } else {
		// â˜…â˜…â˜… ä¿®æ­£ç®‡æ‰€: åœæ­¢ä¸­ã¯ã€Œæ“ä½œç›´å¾Œã€ã®ã¿è¨ˆç®—ã‚’å®Ÿè¡Œã™ã‚‹ (ãƒ‰ãƒªãƒ•ãƒˆé˜²æ­¢) â˜…â˜…â˜…
                if (updateFrames > 0) {
                    solveCircuit();
                    updateFrames--;
                }
            }
            
            draw(); drawGraph();
            if(selectedParts.length===1) updateMeasurements();
        }
        requestAnimationFrame(loop);
    }
  resize(); resizeGraph(); loop();
</script>
</body>
</html>

