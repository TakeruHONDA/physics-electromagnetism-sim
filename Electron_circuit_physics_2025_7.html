<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>電気回路シミュレーター 2026 (Physics Perfect Edition)</title>
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
    <script defer
      src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
      crossorigin="anonymous"
      onload="try{
          renderMathInElement(document.body, {
              delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false},
                  {left: '\\(', right: '\\)', display: false},
                  {left: '\\[', right: '\\]', display: true}
              ],
              throwOnError: false
          });
      } catch(e) { console.error(e); }"></script>

    <style>
        :root {
            --primary-color: #2c3e50; --accent-color: #3498db; --bg-color: #f4f4f9;
            --text-color: #333; --graph-bg: #fff; --success-color: #27ae60; --danger-color: #e74c3c; --warning-color: #f39c12;
        }
        body { font-family: 'Helvetica Neue', Arial, sans-serif; margin: 0; background: var(--bg-color); color: var(--text-color); display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        .tab-nav { background: #fff; padding: 0 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); z-index: 20; display: flex; align-items: center; height: 50px; flex-shrink: 0; }
        .tab-btn { background: none; border: none; padding: 15px 25px; font-size: 16px; font-weight: bold; color: #7f8c8d; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.3s; }
        .tab-btn:hover { color: var(--accent-color); }
        .tab-btn.active { color: var(--primary-color); border-bottom: 3px solid var(--accent-color); }
        .app-title { margin-left: auto; font-size: 14px; color: #999; font-weight: normal; }
        .content-area { flex-grow: 1; position: relative; overflow: hidden; }
        .tab-pane { display: none; width: 100%; height: 100%; overflow-y: auto; }
        .tab-pane.active { display: flex; flex-direction: column; }
        #theory-pane { background: #fff; padding: 40px; box-sizing: border-box; max-width: 900px; margin: 0 auto; }
        h1 { border-bottom: 2px solid var(--accent-color); padding-bottom: 10px; color: var(--primary-color); }
        h2 { margin-top: 40px; border-left: 5px solid var(--accent-color); padding-left: 10px; color: var(--primary-color); background: #f9f9f9; padding: 10px; }
        h3 { margin-top: 25px; color: #555; }
        .box { background: #eef7fb; border: 1px solid #cceeff; padding: 15px; border-radius: 5px; margin: 15px 0; }
        #simulation-pane { flex-direction: row; height: 100%; overflow: hidden; }
        #sim-sidebar { width: 280px; background: #2c3e50; color: #ecf0f1; display: flex; flex-direction: column; padding: 15px; box-shadow: 2px 0 10px rgba(0,0,0,0.3); z-index: 10; overflow-y: auto; flex-shrink: 0; }
        #sim-sidebar h2 { border-bottom: 1px solid #7f8c8d; padding-bottom: 8px; color: #bdc3c7; font-size: 14px; text-transform: uppercase; margin-bottom: 15px; }
        .btn-group { display: flex; flex-direction: column; gap: 8px; margin-bottom: 20px; }
        .sim-btn { background: #34495e; color: #ecf0f1; border: 1px solid #465c71; padding: 10px 15px; cursor: pointer; text-align: left; border-radius: 6px; transition: all 0.2s; display: flex; align-items: center; font-size: 14px; }
        .sim-btn:hover { background: #465c71; transform: translateX(2px); }
        .sim-btn.active { background: #3498db; border-color: #2980b9; font-weight: bold; }
        .icon { width: 24px; text-align: center; margin-right: 12px; font-weight: bold; font-size: 16px; }
        .control-panel { display: flex; gap: 5px; margin-bottom: 10px; }
        .ctrl-btn { flex: 1; padding: 8px 0; border: none; border-radius: 4px; color: white; font-weight: bold; cursor: pointer; font-size: 13px; display: flex; justify-content: center; align-items: center; }
        .btn-start { background-color: var(--success-color); } .btn-stop { background-color: var(--danger-color); } .btn-reset { background-color: var(--warning-color); }
        .btn-toggle-all { width: 100%; padding: 8px 0; background-color: #8e44ad; color: white; border:none; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 13px; margin-bottom: 15px; }
        #properties { margin-bottom: 20px; background: #3e5062; padding: 15px; border-radius: 8px; }
        .prop-row { display: flex; justify-content: space-between; margin-bottom: 8px; align-items: center; font-size: 13px; }
        .prop-row input[type="number"] { width: 70px; padding: 4px; border-radius: 4px; border: none; font-weight: bold; color: #333; }
        .monitor-val { font-family: 'Consolas', monospace; color: #2ecc71; font-weight: bold; font-size: 15px; }
        #main-view { flex-grow: 1; display: flex; flex-direction: column; position: relative; background: #fff; overflow: hidden; }
        #canvas-wrapper { flex-grow: 1; position: relative; overflow: hidden; border-bottom: 1px solid #ccc; }
        #circuitCanvas { display: block; width: 100%; height: 100%; }
        #canvas-wrapper::before { content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: radial-gradient(#d0d0d0 1px, transparent 1px); background-size: 20px 20px; pointer-events: none; opacity: 0.5; }
        #graph-wrapper { height: 220px; background: var(--graph-bg); border-top: 1px solid #ddd; position: relative; padding: 5px; box-sizing: border-box; flex-shrink: 0; display: flex; flex-direction: column; }
        #graphCanvas { width: 100%; height: 100%; display: block; }
        .sim-info { position: absolute; top: 15px; right: 15px; background: rgba(255,255,255,0.95); padding: 15px; border: 1px solid #ddd; border-left: 4px solid #3498db; border-radius: 4px; pointer-events: none; font-size: 13px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); width: 280px; color: #333; }
        .status-badge { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: bold; color: white; margin-bottom: 5px; }
        .status-running { background: var(--success-color); } .status-stopped { background: var(--danger-color); }
    </style>
</head>
<body>

<div class="tab-nav">
    <button class="tab-btn active" onclick="switchTab('theory')">基礎知識</button>
    <button class="tab-btn" onclick="switchTab('simulation')">シミュレーション</button>
    <div class="app-title">電気回路シミュレーター 2026 (Physics Perfect Edition)</div>
</div>

<div class="content-area">
    <div id="theory-pane" class="tab-pane active">
        <div class="theory-container">
            <h1>電気回路理論の基礎 (Fundamental Circuit Theory)</h1>
            <p>本セクションでは、古典的なオームの法則から始まり、微分方程式による過渡現象の解析、そして複素数を用いた交流理論（フェーザ法）までを概観します。</p>

            <h2>1. 回路素子の厳密な定義</h2>
            <p>電圧 \(v(t)\) と電流 \(i(t)\) の関係（構成方程式）は、時間微分・積分を用いて以下のように定義されます。</p>
            
            <h3>抵抗 (Resistor)</h3>
            <div class="box">
                $$v(t) = R i(t)$$
                <p>エネルギーを熱として散逸させる素子です。</p>
            </div>

            <h3>コイル (Inductor)</h3>
            <div class="box">
                $$v(t) = L \frac{di(t)}{dt} \quad \Longleftrightarrow \quad i(t) = i(0) + \frac{1}{L} \int_{0}^{t} v(\tau) d\tau$$
                <p>電流の変化を妨げる方向に起電力を生じます（ファラデーの電磁誘導の法則）。磁気エネルギー \( W_L = \frac{1}{2}Li^2 \) を蓄えます。</p>
            </div>

            <h3>コンデンサー (Capacitor)</h3>
            <div class="box">
                $$i(t) = C \frac{dv(t)}{dt} \quad \Longleftrightarrow \quad v(t) = v(0) + \frac{1}{C} \int_{0}^{t} i(\tau) d\tau$$
                <p>電荷 \(q(t) = Cv(t)\) を蓄える素子です。静電エネルギー \( W_C = \frac{1}{2}Cv^2 \) を蓄えます。</p>
                <p><strong>物理的構造による容量決定:</strong> 平行板コンデンサーの場合、極板面積 \(S\)、極板間距離 \(d\)、誘電率 \(\varepsilon\) を用いて以下のように表されます。</p>
                $$C = \varepsilon \frac{S}{d}$$
            </div>

            <h2>2. キルヒホッフの法則 (Kirchhoff's Laws)</h2>
            <p>回路解析の基礎となる2つの保存則です。</p>
            <ul>
                <li><strong>第1法則（KCL: 電流則）</strong>：任意の接続点（ノード）において、流入する電流の和と流出する電流の和は等しい（電荷保存則）。
                $$\sum_{k} i_k(t) = 0$$
                </li>
                <li><strong>第2法則（KVL: 電圧則）</strong>：任意の閉回路（ループ）において、電圧降下の総和は起電力の総和に等しい（エネルギー保存則）。
                $$\sum_{k} v_k(t) = 0$$
                </li>
            </ul>

            <h2>3. 過渡現象 (Transient Response)</h2>
            <p>スイッチ操作直後など、定常状態に達するまでの時間変化を記述します。線形微分方程式を解くことで解析します。</p>

            <h3>RC直列回路の充電過程</h3>
            <p>抵抗 \(R\) とコンデンサー \(C\) の直列回路に、時刻 \(t=0\) で直流電圧 \(E\) を印加した場合の電圧方程式（KVL）は以下のようになります。</p>
            <div class="box">
                $$R i(t) + \frac{1}{C} \int i(t) dt = E$$
                両辺を時間微分して整理すると、電流 \(i(t)\) に関する1階線形微分方程式が得られます。
                $$R \frac{di}{dt} + \frac{1}{C} i = 0$$
                <strong>解:</strong>
                $$i(t) = \frac{E}{R} e^{-\frac{t}{RC}}, \quad v_C(t) = E (1 - e^{-\frac{t}{RC}})$$
            </div>
            <p>ここで、積 \( \tau = RC \) を<strong>時定数 (Time Constant)</strong> と呼び、応答の速さを表します。</p>

            <h3>RL直列回路の応答</h3>
            <div class="box">
                $$L \frac{di}{dt} + Ri = E$$
                <strong>解 (電流):</strong>
                $$i(t) = \frac{E}{R} (1 - e^{-\frac{R}{L}t})$$
            </div>
            <p>時定数は \( \tau = \frac{L}{R} \) です。</p>

            <h2>4. 交流回路と複素インピーダンス (AC & Complex Impedance)</h2>
            <p>角周波数 \(\omega\) の正弦波交流定常状態において、電圧と電流を複素数（フェーザ）で扱うことで、微分方程式を代数方程式として解くことができます（オイラーの公式 \(e^{j\theta} = \cos\theta + j\sin\theta\) の応用）。</p>

            <div class="box">
                <strong>インピーダンス \(Z\) の定義:</strong> $$\dot{V} = Z \dot{I}$$
                <ul>
                    <li>抵抗: \( Z_R = R \) （位相差なし）</li>
                    <li>コイル: \( Z_L = j\omega L \) （電圧が電流より \(\pi/2\) 進む）</li>
                    <li>コンデンサー: \( Z_C = \frac{1}{j\omega C} = -j\frac{1}{\omega C} \) （電圧が電流より \(\pi/2\) 遅れる）</li>
                </ul>
                <small>※電気工学では虚数単位に \(i\) ではなく \(j\) を用います。</small>
            </div>

            <h3>RLC直列回路と共振</h3>
            <p>合成インピーダンス \(Z\) は以下のようになります。</p>
            <div class="box">
                $$Z = R + j\left( \omega L - \frac{1}{\omega C} \right)$$
                回路を流れる電流の大きさは \( |I| = \frac{|V|}{\sqrt{R^2 + (\omega L - \frac{1}{\omega C})^2}} \) となります。
            </div>
            <p>虚部がゼロになる周波数 \( \omega_0 = \frac{1}{\sqrt{LC}} \) においてインピーダンスが最小（\(Z=R\)）となり、電流が最大化します。これを<strong>直列共振</strong>と呼びます。</p>

            <h2>5. 電力 (Power)</h2>
            <div class="box">
                <ul>
                    <li><strong>瞬時電力:</strong> \( p(t) = v(t)i(t) \)</li>
                    <li><strong>有効電力 (Active Power) \(P\):</strong> 実際に消費される電力の平均値。単位はワット[W]。
                    $$P = V_{eff} I_{eff} \cos \phi$$
                    （\(\cos \phi\) は力率）</li>
                    <li><strong>無効電力 (Reactive Power) \(Q\):</strong> 電源と素子の間を往復するだけの電力。単位はバール[var]。
                    $$Q = V_{eff} I_{eff} \sin \phi$$
                    </li>
                    <li><strong>皮相電力 (Apparent Power) \(S\):</strong> 回路設計上の容量。単位はボルトアンペア[VA]。
                    $$S = \sqrt{P^2 + Q^2} = V_{eff} I_{eff}$$
                    </li>
                </ul>
            </div>
        </div>
    </div>

    <div id="simulation-pane" class="tab-pane">
        <div id="sim-sidebar">
            <h2>実行制御</h2>
            <div class="control-panel">
                <button class="ctrl-btn btn-start" onclick="startSim()">▶ 開始</button>
                <button class="ctrl-btn btn-stop" onclick="stopSim()">⏸ 停止</button>
                <button class="ctrl-btn btn-reset" onclick="resetSim()">⟲ リセット</button>
            </div>
            <button class="btn-toggle-all" onclick="toggleAllSwitches()">⚡ 全スイッチ切替</button>

            <div id="properties">
                <span style="font-weight:bold; color:#bdc3c7; display:block; margin-bottom:10px; border-bottom:1px solid #566b80;">プロパティ</span>
                <div id="prop-content" style="min-height: 80px; display:flex; flex-direction: column; align-items:center; justify-content:center; color:#95a5a6; font-size:12px;">部品を選択</div>
                <div style="margin-top:15px; display:flex; gap:5px;">
                    <button onclick="deleteSelected()" style="background:#e74c3c; border:none; color:white; padding:8px; border-radius:4px; flex:1; cursor:pointer;">削除</button>
                    <button onclick="clearWires()" style="background:#f39c12; border:none; color:white; padding:8px; border-radius:4px; flex:1; cursor:pointer;">全配線消去</button>
                </div>
            </div>

            <h2>ツール</h2>
            <div class="btn-group">
                <button onclick="setTool('select')" id="btn-select" class="sim-btn active"><span class="icon">➤</span>選択 / 移動</button>
                <button onclick="rotateSelected()" class="sim-btn"><span class="icon">↻</span>回転 (R)</button>
                <button onclick="setTool('wire')" id="btn-wire" class="sim-btn"><span class="icon">✎</span>ワイヤー (配線)</button>
            </div>
            
            <h2>素子</h2>
            <div class="btn-group">
                <button onclick="addPart('source')" class="sim-btn"><span class="icon">⎓</span>直流電源</button>
                <button onclick="addPart('ac_source')" class="sim-btn"><span class="icon">∼</span>交流電源</button>
                <button onclick="addPart('switch')" class="sim-btn"><span class="icon">_/_</span>スイッチ</button>
                <button onclick="addPart('resistor')" class="sim-btn"><span class="icon">R</span>抵抗</button>
                <button onclick="addPart('capacitor')" class="sim-btn"><span class="icon">C</span>コンデンサー</button>
                <button onclick="addPart('inductor')" class="sim-btn"><span class="icon">L</span>コイル</button>
            </div>
            <h2>計測器</h2>
            <div class="btn-group">
                <button onclick="addPart('voltmeter')" class="sim-btn"><span class="icon">V</span>電圧計</button>
                <button onclick="addPart('ammeter')" class="sim-btn"><span class="icon">A</span>電流計</button>
                <button onclick="addPart('galvanometer')" class="sim-btn"><span class="icon">G</span>検流計</button>
            </div>
        </div>

        <div id="main-view">
            <div id="canvas-wrapper">
                <canvas id="circuitCanvas"></canvas>
                <div class="sim-info">
                    <span id="sim-status-badge" class="status-badge status-stopped">停止中</span>
                    <strong style="color:#2c3e50; font-size:14px;">配線のコツ (直交モード)</strong><br>
                    <div style="margin-top:8px; line-height:1.4; color:#555;">
                    1. 配線は自動的に<span style="color:#3498db;font-weight:bold;">縦・横(L字)</span>になります<br>
                    2. 何もない所までドラッグして放すと<br>
                       <span style="color:#e67e22; font-weight:bold;">● 中継点 (Joint)</span> を作成します<br>
                    3. これで障害物を避けて配線できます
                    </div>
                </div>
            </div>
            <div id="graph-wrapper">
                <div style="font-size:12px; color:#555; margin-bottom:2px; display:flex; justify-content:space-between; height: 20px;">
                    <strong>波形比較モニター</strong><span id="graph-legend">素子を1つ選択するとグラフが表示されます</span>
                </div>
                <canvas id="graphCanvas"></canvas>
            </div>
        </div>
    </div>
</div>

<script>
    function renderLatexInElement(element) {
        if (typeof renderMathInElement === 'function' && element) {
            try { renderMathInElement(element, { delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}], throwOnError: false }); } catch (e) {}
        }
    }

    function switchTab(tabId) {
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.remove('active');
            if(btn.innerText.includes(tabId === 'theory' ? '基礎' : 'シミュレーション')) btn.classList.add('active');
        });
        document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
        if(tabId === 'theory') document.getElementById('theory-pane').classList.add('active');
        else {
            document.getElementById('simulation-pane').classList.add('active');
            setTimeout(() => { resize(); resizeGraph(); }, 0);
        }
    }

    const canvas = document.getElementById('circuitCanvas');
    const ctx = canvas.getContext('2d');
    const graphCanvas = document.getElementById('graphCanvas');
    const gCtx = graphCanvas.getContext('2d');
    
    let width, height, graphW, graphH;
    const parts = []; let wires = []; const nodes = [];   
    let selectedParts = []; let currentTool = 'select';
    let isDragging = false; let dragStartNode = null;
    let lastMousePos = { x: 0, y: 0 }; let mousePos = { x: 0, y: 0 }; let hoverNode = null;
    let isBoxSelecting = false; let selectionBox = { x: 0, y: 0, w: 0, h: 0 };

    let isRunning = false; let simTime = 0; const dt = 0.001; let animationOffset = 0; 
    const ITERATIONS = 5000; const INTERNAL_R_SRC = 1e-5; const R_SWITCH_CLOSED = 1e-5;    
    const R_SWITCH_OPEN = 1e9; const INTERNAL_R_AMMETER = 1e-5; const G_LEAK = 1e-12;            
    const MAX_HISTORY = 400; const historyData = []; const GRID_SIZE = 20;

    function formatValue(val, unit, useAbs = true) {
        let v = useAbs ? Math.abs(val) : val;
        if (Math.abs(v) < 1e-10) v = 0;
        let sign = (v < 0) ? "-" : ""; let absVal = Math.abs(v); let prefix = "";
        if (absVal < 1e-9 && absVal !== 0) { absVal *= 1e12; prefix = "p"; }
        else if (absVal < 1e-6 && absVal !== 0) { absVal *= 1e9; prefix = "n"; }
        else if (absVal < 1e-3 && absVal !== 0) { absVal *= 1e6; prefix = "µ"; }
        else if (absVal < 1 && absVal !== 0) { absVal *= 1e3; prefix = "m"; }
        else if (absVal >= 1e3 && absVal < 1e6) { absVal /= 1e3; prefix = "k"; }
        else if (absVal >= 1e6) { absVal /= 1e6; prefix = "M"; }
        return sign + absVal.toFixed(2) + " " + prefix + unit;
    }

    class Node {
        constructor(parentPart, offsetX, offsetY) {
            this.parentPart = parentPart; this.offsetX = offsetX; this.offsetY = offsetY;
            this.voltage = 0; this.netId = -1;
        }
        get x() { const cos = Math.cos(this.parentPart.rotation), sin = Math.sin(this.parentPart.rotation); return this.parentPart.x + (this.offsetX * cos - this.offsetY * sin); }
        get y() { const cos = Math.cos(this.parentPart.rotation), sin = Math.sin(this.parentPart.rotation); return this.parentPart.y + (this.offsetX * sin + this.offsetY * cos); }
    }

    class Part {
        constructor(type, x, y) {
            this.type = type; this.x = x; this.y = y; this.rotation = 0; 
            this.nodes = []; this.value = 0; this.label = ""; this.current = 0; 
            this.freq = 1.0; this.amplitude = 10; this.voltageState = 0; this.isOpen = false; 
            
            // コンデンサー用追加プロパティ
            this.cap_d = 1.0; // 極板間距離 (相対値)
            this.cap_s = 1.0; // 極板面積 (相対値)
            this.cap_e = 1.0; // 比誘電率
            this.cap_x = 0.0; // 誘電体挿入率 (0.0 - 1.0)
            this.base_C = 10.0; // 基準容量 (µF)

            this.initType();
        }
        initType() {
            switch(this.type) {
                case 'source': this.nodes.push(new Node(this, -40, 0)); this.nodes.push(new Node(this, 40, 0)); this.value = 10; this.label = "10V"; break;
                case 'ac_source': this.nodes.push(new Node(this, -40, 0)); this.nodes.push(new Node(this, 40, 0)); this.amplitude = 10; this.freq = 1.0; this.label = "10V\n1Hz"; break;
                case 'switch': this.nodes.push(new Node(this, -30, 0)); this.nodes.push(new Node(this, 30, 0)); this.label = "SW"; this.isOpen = false; break;
                case 'resistor': this.nodes.push(new Node(this, -40, 0)); this.nodes.push(new Node(this, 40, 0)); this.value = 100; this.label = "100Ω"; break;
                case 'capacitor': 
                    this.nodes.push(new Node(this, -20, 0)); this.nodes.push(new Node(this, 20, 0)); 
                    this.value = 10; // 初期値
                    this.label = "10.0µF"; 
                    break;
                case 'inductor': this.nodes.push(new Node(this, -30, 0)); this.nodes.push(new Node(this, 30, 0)); this.value = 1; this.label = "1H"; break;
                case 'voltmeter': this.nodes.push(new Node(this, -30, 0)); this.nodes.push(new Node(this, 30, 0)); this.value = 1e6; this.label = "Vm"; break;
                case 'ammeter': this.nodes.push(new Node(this, -30, 0)); this.nodes.push(new Node(this, 30, 0)); this.value = INTERNAL_R_AMMETER; this.label = "Am"; break;
                case 'galvanometer': this.nodes.push(new Node(this, -30, 0)); this.nodes.push(new Node(this, 30, 0)); this.value = 5; this.label = "G"; break;
                case 'joint': this.nodes.push(new Node(this, 0, 0)); this.label = ""; break; 
            }
            this.nodes.forEach(n => nodes.push(n));
        }
        
        rotate() { this.rotation += Math.PI / 2; if (this.rotation > Math.PI) this.rotation -= Math.PI * 2; }
        getVoltageDiff() { if(this.nodes.length<2) return 0; return this.nodes[0].voltage - this.nodes[1].voltage; }
        getCharge() { if (this.type !== 'capacitor') return 0; return (this.value * 1e-6) * this.getVoltageDiff(); }

        draw(ctx) {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
            if (selectedParts.includes(this)) {
                ctx.shadowBlur = 10; ctx.shadowColor = "#3498db"; ctx.strokeStyle = "rgba(52, 152, 219, 0.8)"; ctx.lineWidth = 2;
                if(this.type === 'joint') ctx.strokeRect(-8, -8, 16, 16);
                else ctx.strokeRect(-50, -35, 100, 70);
                ctx.shadowBlur = 0;
                
                if(this.type !== 'joint') {
                    ctx.fillStyle = "#e74c3c"; ctx.font = "bold 14px Arial"; ctx.fillText("+", this.nodes[0].offsetX, -25);
                    ctx.fillStyle = "#3498db"; ctx.fillText("-", this.nodes[1].offsetX, -25);
                    if (!['voltmeter'].includes(this.type)) {
                        ctx.strokeStyle = "#f39c12"; ctx.lineWidth = 2; ctx.beginPath();
                        let n0x = this.nodes[0].offsetX, n1x = this.nodes[1].offsetX;
                        ctx.moveTo(n0x + 10, 20); ctx.lineTo(n1x - 10, 20); ctx.lineTo(n1x - 15, 17); ctx.moveTo(n1x - 10, 20); ctx.lineTo(n1x - 15, 23);
                        ctx.stroke(); ctx.fillStyle = "#f39c12"; ctx.font = "10px Arial"; ctx.fillText("I (+)", 0, 28);
                    }
                }
            }
            if (isRunning && Math.abs(this.current) > 1e-9 && !['voltmeter', 'joint'].includes(this.type)) {
                const speed = this.current * 100; const dotOffset = (animationOffset * speed) % 20;
                ctx.fillStyle = "#f1c40f"; ctx.beginPath();
                for(let lx = -30; lx <= 30; lx += 15) {
                    let drawX = lx + dotOffset; if (drawX > 30) drawX -= 60; if (drawX < -30) drawX += 60;
                    if (drawX >= -35 && drawX <= 35) ctx.arc(drawX, 0, 2.5, 0, Math.PI*2);
                }
                ctx.fill();
            }
            
            if(this.type === 'joint') {
                ctx.fillStyle = "#2c3e50"; ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill();
            } else {
                ctx.strokeStyle = "#2c3e50"; ctx.lineWidth = 2; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                this.nodes.forEach(n => {
                    ctx.beginPath();
                    let startX = (n.offsetX > 0) ? n.offsetX - 10 : n.offsetX + 10;
                    
                    // コンデンサーの場合、極板の位置に合わせて端子線の長さを変える
                    if (this.type === 'capacitor') {
                        const plateOff = Math.min(15, Math.max(2, 5 * this.cap_d)); 
                        startX = (n.offsetX > 0) ? plateOff : -plateOff;
                    }
                    else if (this.type === 'switch') startX = (n.offsetX > 0) ? n.offsetX - 10 : n.offsetX + 10;
                    
                    ctx.moveTo(startX, n.offsetY); ctx.lineTo(n.offsetX, n.offsetY); ctx.stroke();
                    ctx.beginPath(); ctx.fillStyle = "#2c3e50"; ctx.arc(n.offsetX, n.offsetY, 4, 0, Math.PI*2); ctx.fill();
                });
                ctx.beginPath();
                if (this.type === 'resistor') { ctx.moveTo(-30, 0); for(let i=0; i<6; i++) ctx.lineTo(-25 + i*10, (i%2==0 ? -1 : 1) * 10); ctx.lineTo(30, 0); ctx.stroke(); } 
                else if (this.type === 'switch') { ctx.moveTo(-30, 0); ctx.lineTo(-20, 0); ctx.moveTo(30, 0); ctx.lineTo(20, 0); ctx.stroke(); ctx.beginPath(); if (this.isOpen) { ctx.moveTo(-20, 0); ctx.lineTo(15, -15); } else { ctx.moveTo(-20, 0); ctx.lineTo(20, 0); } ctx.stroke(); ctx.beginPath(); ctx.arc(-20, 0, 3, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(20, 0, 3, 0, Math.PI*2); if(!this.isOpen) ctx.fill(); else ctx.stroke(); } 
                else if (this.type === 'source') { ctx.moveTo(-10, -12); ctx.lineTo(-10, 12); ctx.stroke(); ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(10, -20); ctx.lineTo(10, 20); ctx.stroke(); ctx.lineWidth = 2; ctx.font = "16px Arial"; ctx.fillStyle = "#7f8c8d"; ctx.fillText("+", 22, -15); } 
                else if (this.type === 'ac_source') { ctx.fillStyle = "#fff"; ctx.arc(0, 0, 18, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(-10, 0); ctx.bezierCurveTo(-5, -8, 0, 8, 5, 0); ctx.bezierCurveTo(8, -5, 12, 5, 10, 0); ctx.stroke(); } 
                else if (this.type === 'capacitor') { 
                    // 極板描画位置の計算 (距離スライダー値に連動)
                    const plateOff = Math.min(15, Math.max(2, 5 * this.cap_d));
                    
                    // ★ 変更: 極板高さの計算 (面積スライダー値に連動) 基準高さ18
                    const plateH = 18 * this.cap_s;

                    // 誘電体挿入アニメーション (Dielectric Insertion Animation)
                    if (this.cap_x > 0) {
                        ctx.save();
                        ctx.fillStyle = "rgba(39, 174, 96, 0.5)"; // 緑色の半透明
                        // 上端(-plateH)から、高さ(2*plateH * 挿入率) 分だけ描画
                        const h = 2 * plateH * this.cap_x;
                        ctx.fillRect(-plateOff, -plateH, plateOff * 2, h);
                        ctx.restore();
                    }
                    // 極板の描画 (可変位置・可変高さ)
                    ctx.moveTo(-plateOff, -plateH); ctx.lineTo(-plateOff, plateH); 
                    ctx.moveTo(plateOff, -plateH); ctx.lineTo(plateOff, plateH); 
                    ctx.stroke(); 
                } 
                else if (this.type === 'inductor') { ctx.beginPath(); const r = 6; for(let i=-2; i<=1; i++) { ctx.arc(i*10 + 5, -r, r, 0, Math.PI); } ctx.stroke(); } 
                else if (['voltmeter', 'ammeter', 'galvanometer'].includes(this.type)) { ctx.fillStyle = "#ecf0f1"; ctx.beginPath(); ctx.arc(0,0, 24, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle = "#2c3e50"; ctx.font = "bold 18px Arial"; let sym = this.type === 'galvanometer' ? 'G' : (this.type === 'voltmeter' ? 'V' : 'A'); ctx.fillText(sym, 0, -5); ctx.fillStyle = "rgba(255, 255, 255, 0.9)"; ctx.fillRect(-40, 12, 80, 22); ctx.strokeStyle = "#bdc3c7"; ctx.lineWidth = 1; ctx.strokeRect(-40, 12, 80, 22); ctx.fillStyle = "#0055aa"; ctx.font = "bold 13px Consolas, monospace"; ctx.fillText(formatValue(this.type==='voltmeter'?Math.abs(this.getVoltageDiff()):Math.abs(this.current), this.type==='voltmeter'?"V":"A", true), 0, 24); }
                if (!['voltmeter', 'ammeter', 'galvanometer'].includes(this.type)) { ctx.fillStyle = "#555"; ctx.font = "12px Arial"; ctx.fillText(this.label, 0, -28); }
            }
            ctx.restore();
        }
    }

    function resize() { const c=document.getElementById('canvas-wrapper'); if(c&&c.clientWidth>0){width=canvas.width=c.clientWidth; height=canvas.height=c.clientHeight;} }
    function resizeGraph() { const c=document.getElementById('graph-wrapper'); if(c&&c.clientWidth>0){graphW=graphCanvas.width=c.clientWidth; graphH=graphCanvas.height=c.clientHeight-30;} }
    window.addEventListener('resize', () => { resize(); resizeGraph(); });

    function startSim() { isRunning = true; updateStatus(); }
    function stopSim() { isRunning = false; updateStatus(); }
    function resetSim() { isRunning = false; simTime = 0; historyData.length = 0; parts.forEach(p => { p.current = 0; p.voltageState = 0; if(p.type === 'ac_source') p.value = 0; }); nodes.forEach(n => n.voltage = 0); updateStatus(); updateProperties(); draw(); drawGraph(); }
    function updateStatus() { const b=document.getElementById('sim-status-badge'); b.textContent=isRunning?"実行中":"停止中"; b.className=isRunning?"status-badge status-running":"status-badge status-stopped"; }

    function setTool(tool) { currentTool = tool; document.querySelectorAll('.sim-btn').forEach(b => b.classList.remove('active')); if(tool === 'select') document.getElementById('btn-select').classList.add('active'); if(tool === 'wire') document.getElementById('btn-wire').classList.add('active'); selectedParts = []; historyData.length = 0; updateProperties(); draw(); }
    function addPart(type) { const cx = Math.round((width?width/2:400)/GRID_SIZE)*GRID_SIZE; const cy = Math.round((height?height/2:300)/GRID_SIZE)*GRID_SIZE; const part = new Part(type, cx, cy); parts.push(part); setTool('select'); selectedParts = [part]; updateProperties(); draw(); }
    function rotateSelected() { selectedParts.forEach(p => p.rotate()); draw(); }
    function toggleAllSwitches() { let c = false; parts.forEach(p => { if(p.type === 'switch') { p.isOpen = !p.isOpen; c = true; } }); if(c) { draw(); if(selectedParts.length === 1 && selectedParts[0].type === 'switch') updateProperties(); } }

    document.addEventListener('keydown', (e) => {
        if(document.getElementById('simulation-pane').classList.contains('active')) {
            if (e.key === 'r' || e.key === 'R') rotateSelected();
            if (e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
            if (e.key === ' ' || e.code === 'Space') { e.preventDefault(); const h = findPartAt(mousePos.x, mousePos.y); if (h && h.type === 'switch') { h.isOpen = !h.isOpen; draw(); if (selectedParts.includes(h)) updateProperties(); return; } if (selectedParts.length === 1 && selectedParts[0].type === 'switch') { selectedParts[0].isOpen = !selectedParts[0].isOpen; updateProperties(); draw(); } }
        }
    });

    function deleteSelected() {
        if (selectedParts.length > 0) {
            selectedParts.forEach(part => {
                const idx = parts.indexOf(part);
                if (idx > -1) {
                    const partNodes = part.nodes;
                    wires = wires.filter(w => !partNodes.includes(w.start) && !partNodes.includes(w.end));
                    partNodes.forEach(n => { const nIdx = nodes.indexOf(n); if (nIdx > -1) nodes.splice(nIdx, 1); });
                    parts.splice(idx, 1);
                }
            });
            selectedParts = []; historyData.length = 0; updateProperties(); draw();
        }
    }
    function clearWires() { wires = []; parts.filter(p=>p.type==='joint').forEach(j=>{const idx=parts.indexOf(j); if(idx>-1){parts.splice(idx,1); j.nodes.forEach(n=>{const ni=nodes.indexOf(n); if(ni>-1)nodes.splice(ni,1);});}}); draw(); }

    function getMousePos(e) { const r = canvas.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }
    function findNodeAt(x, y) { return nodes.find(n => Math.hypot(n.x - x, n.y - y) < 15); }
    function findPartAt(x, y) { return parts.find(p => Math.abs(p.x - x) < 40 && Math.abs(p.y - y) < 25); }

    canvas.addEventListener('mousedown', e => {
        mousePos = getMousePos(e); lastMousePos = { ...mousePos };
        if (e.button === 2) { isDragging = false; dragStartNode = null; isBoxSelecting = false; selectedParts = []; historyData.length = 0; updateProperties(); draw(); return; }
        if (currentTool === 'select') {
            const part = findPartAt(mousePos.x, mousePos.y);
            if (part) {
                if (e.shiftKey) { const idx = selectedParts.indexOf(part); if (idx > -1) selectedParts.splice(idx, 1); else selectedParts.push(part); } 
                else { if (!selectedParts.includes(part)) { selectedParts = [part]; historyData.length = 0; } }
                isDragging = true;
            } else { if (!e.shiftKey) { selectedParts = []; historyData.length = 0; } isBoxSelecting = true; selectionBox = { x: mousePos.x, y: mousePos.y, w: 0, h: 0 }; }
            updateProperties();
        } else if (currentTool === 'wire') {
            const node = findNodeAt(mousePos.x, mousePos.y);
            if (node) { dragStartNode = node; isDragging = true; }
            else { const gx = Math.round(mousePos.x/GRID_SIZE)*GRID_SIZE; const gy = Math.round(mousePos.y/GRID_SIZE)*GRID_SIZE; const joint = new Part('joint', gx, gy); parts.push(joint); nodes.push(joint.nodes[0]); dragStartNode = joint.nodes[0]; isDragging = true; draw(); }
        }
        draw();
    });
    
    canvas.addEventListener('mouseup', e => {
        if (currentTool === 'select') {
            if (isDragging && selectedParts.length > 0) { selectedParts.forEach(p => { p.x = Math.round(p.x / GRID_SIZE) * GRID_SIZE; p.y = Math.round(p.y / GRID_SIZE) * GRID_SIZE; }); } 
            else if (isBoxSelecting) {
                const x1 = Math.min(selectionBox.x, selectionBox.x + selectionBox.w), x2 = Math.max(selectionBox.x, selectionBox.x + selectionBox.w);
                const y1 = Math.min(selectionBox.y, selectionBox.y + selectionBox.h), y2 = Math.max(selectionBox.y, selectionBox.y + selectionBox.h);
                parts.forEach(p => { if (p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2 && !selectedParts.includes(p)) selectedParts.push(p); });
                updateProperties();
            }
        } else if (currentTool === 'wire' && isDragging && dragStartNode) {
            let targetNode = findNodeAt(mousePos.x, mousePos.y);
            if (!targetNode) {
                const gx = Math.round(mousePos.x/GRID_SIZE)*GRID_SIZE; const gy = Math.round(mousePos.y/GRID_SIZE)*GRID_SIZE;
                const existingJoint = parts.find(p=>p.type==='joint' && Math.abs(p.x-gx)<5 && Math.abs(p.y-gy)<5);
                if(existingJoint) targetNode = existingJoint.nodes[0];
                else { const joint = new Part('joint', gx, gy); parts.push(joint); nodes.push(joint.nodes[0]); targetNode = joint.nodes[0]; }
            }
            if (targetNode && targetNode !== dragStartNode) {
                const exists = wires.some(w => (w.start === dragStartNode && w.end === targetNode) || (w.start === targetNode && w.end === dragStartNode));
                if (!exists) wires.push({ start: dragStartNode, end: targetNode });
            }
        }
        isDragging = false; dragStartNode = null; isBoxSelecting = false; draw();
    });

    canvas.addEventListener('dblclick', e => { if (currentTool === 'select') { const p = findPartAt(getMousePos(e).x, getMousePos(e).y); if (p && p.type === 'switch') { p.isOpen = !p.isOpen; draw(); if (selectedParts.includes(p)) updateProperties(); } } });
    canvas.addEventListener('mousemove', e => {
        mousePos = getMousePos(e); hoverNode = findNodeAt(mousePos.x, mousePos.y);
        if (currentTool === 'wire') canvas.style.cursor = hoverNode ? 'crosshair' : 'default'; else canvas.style.cursor = findPartAt(mousePos.x, mousePos.y) ? 'move' : 'default';
        const dx = mousePos.x - lastMousePos.x, dy = mousePos.y - lastMousePos.y; lastMousePos = { ...mousePos };
        if (currentTool === 'select') {
            if (isDragging && selectedParts.length > 0) { selectedParts.forEach(p => { p.x += dx; p.y += dy; }); } 
            else if (isBoxSelecting) { selectionBox.w = mousePos.x - selectionBox.x; selectionBox.h = mousePos.y - selectionBox.y; }
        }
        draw();
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    function updateProperties() {
        const div = document.getElementById('prop-content');
        if (selectedParts.length === 0) { div.innerHTML = "部品を選択してください"; return; } 
        else if (selectedParts.length > 1) { div.innerHTML = selectedParts.length + " 個の部品を選択中"; return; }
        const p = selectedParts[0]; if(p.type === 'joint') { div.innerHTML = "中継点 (配線の結節点)"; return; }
        let html = "";
        const mkInp = (lbl, val, id, st=1) => `<div class="prop-row">${lbl} <input type="number" id="${id}" value="${val}" step="${st}" onchange="chP('${id}', this.value)"></div>`;
        const mkSld = (val, id, mn, mx, st, lbl="調整") => `<div class="prop-row" style="flex-direction:column;align-items:flex-start;"><div style="display:flex;justify-content:space-between;width:100%;"><span>${lbl}</span><span style="font-size:11px;">${mn}-${mx}</span></div><input type="range" id="${id}_rg" value="${val}" min="${mn}" max="${mx}" step="${st}" oninput="chP('${id}', this.value)" style="width:100%;"></div>`;
        
        if (p.type === 'resistor') { html += mkInp("抵抗(Ω)", p.value, "v"); html += mkSld(p.value, "v", 1, 1000, 10); }
        if (p.type === 'switch') html += `<div class="prop-row"><button onclick="toggleSwitch()" style="width:100%;padding:8px;background:${p.isOpen?'#95a5a6':'#27ae60'};color:white;border:none;border-radius:4px;">${p.isOpen?'現在: OFF':'現在: ON'} - 切替</button></div>`;
        if (p.type === 'source') html += mkInp("電圧(V)", p.value, "v");
        if (p.type === 'ac_source') { html += mkInp("最大(V)", p.amplitude, "a"); html += mkInp("周波数(Hz)", p.freq, "f", 0.1); }
        
        // コンデンサー：スライダーUI
        if (p.type === 'capacitor') {
            html += `<div class="prop-row" style="font-weight:bold; color:#3498db;">合成容量: <span id="cap_val_disp">${p.value.toFixed(2)}</span> µF</div>`;
            html += mkSld(p.cap_s, "cap_s", 0.5, 2.0, 0.1, "極板面積 (S)");
            html += mkSld(p.cap_d, "cap_d", 0.1, 5.0, 0.1, "極板間距離 (d)");
            html += mkSld(p.cap_e, "cap_e", 1.0, 10.0, 0.1, "比誘電率 (εr)");
            html += mkSld(p.cap_x, "cap_x", 0.0, 1.0, 0.01, "誘電体挿入 (x)");
        }

        if (p.type === 'inductor') html += mkInp("L(H)", p.value, "v", 0.01);
        if (['source','ac_source'].includes(p.type)) html += `<div class="prop-row">出力電流 <span id="m-i" class="monitor-val">---</span></div>`;
        else if (['resistor','inductor','switch'].includes(p.type)) { html += `<div class="prop-row">電圧 <span id="m-v" class="monitor-val">---</span></div><div class="prop-row">電流 <span id="m-i" class="monitor-val">---</span></div>`; }
        else if (p.type === 'capacitor') { html += `<div class="prop-row">電圧 <span id="m-v" class="monitor-val">---</span></div><div class="prop-row">電荷 <span id="m-q" class="monitor-val monitor-val-q">---</span></div>`; }
        else if (['voltmeter','ammeter','galvanometer'].includes(p.type)) html += `<div class="prop-row">値 <span id="m-val" class="monitor-val">---</span></div>`;
        div.innerHTML = html; updateMeasurements();
    }
    
    function chP(k, v) { 
        if(selectedParts.length!==1)return; 
        const p=selectedParts[0], n=parseFloat(v); 
        if(isNaN(n))return; 

        // 共通プロパティの更新
        if(k==='v'){
            p.value=n; 
            if(p.type==='resistor')p.label=n+"Ω"; 
            if(p.type==='source')p.label=n+"V"; 
            if(p.type==='capacitor')p.label=n.toFixed(1)+"µF"; 
            if(p.type==='inductor')p.label=n+"H"; 
            const s=document.getElementById('v_rg'), b=document.getElementById('v'); 
            if(s&&b){s.value=n;b.value=n;}
        }
        else if(k==='a'){p.amplitude=n; p.label=n+"V\n"+p.freq+"Hz";} 
        else if(k==='f'){p.freq=n; p.label=p.amplitude+"V\n"+n+"Hz";} 
        
        // コンデンサー物理パラメータの更新と再計算
        else if(['cap_d', 'cap_e', 'cap_x', 'cap_s'].includes(k)) {
            // 重要: 電荷保存則 (Q = CV) に基づく過渡現象の計算
            const oldC = p.value; 
            if (k === 'cap_d') p.cap_d = n;
            if (k === 'cap_e') p.cap_e = n;
            if (k === 'cap_x') p.cap_x = n;
            if (k === 'cap_s') p.cap_s = n;
            
            // ★ 静電容量の計算: C = (base_C * S / d) * ((1-x) + e*x)
            const epsilon_eff = (1 - p.cap_x) + (p.cap_e * p.cap_x);
            p.value = (p.base_C * p.cap_s / p.cap_d) * epsilon_eff;
            p.label = p.value.toFixed(1) + "µF";
            
            // 電圧状態の更新 (電荷保存則の適用)
            if (p.value > 1e-12 && oldC > 1e-12) {
                p.voltageState = p.voltageState * (oldC / p.value);
            }
            const disp = document.getElementById('cap_val_disp');
            if(disp) disp.innerText = p.value.toFixed(2);
            draw();
        }
    }

    function toggleSwitch() { if(selectedParts.length===1 && selectedParts[0].type==='switch'){selectedParts[0].isOpen=!selectedParts[0].isOpen; updateProperties(); draw();} }
    function updateMeasurements() {
        if(selectedParts.length!==1)return; const p=selectedParts[0];
        const setT = (id, v, u) => { const e=document.getElementById(id); if(e)e.innerText=formatValue(v, u, true); };
        if(['source','ac_source'].includes(p.type)) setT('m-i', p.current, "A");
        else if(['resistor','inductor','switch'].includes(p.type)) { setT('m-v', p.getVoltageDiff(), "V"); setT('m-i', p.current, "A"); }
        else if(p.type==='capacitor') { setT('m-v', p.getVoltageDiff(), "V"); setT('m-q', p.getCharge(), "C"); }
        else if(['voltmeter','ammeter','galvanometer'].includes(p.type)) setT('m-val', p.type==='voltmeter'?p.getVoltageDiff():p.current, p.type==='voltmeter'?"V":"A");
    }

    // --- ★★★ 物理エンジン (コンパニオンモデルによる厳密解法) ★★★ ---
    function solveCircuit() {
        const nets = []; nodes.forEach(n => n.netId = -1);
        
        // ★修正点: 初期電圧を0ではなく、前回の電圧から引き継ぐように修正
        function traceNet(n, id) { 
            n.netId=id; 
            if(!nets[id]) {
                // 前回フレームの電圧(n.voltage)をシード値として使用
                nets[id]={nodes:[], voltage:n.voltage, fixed:false}; 
            }
            nets[id].nodes.push(n); 
            wires.forEach(w=>{if(w.start===n&&w.end.netId===-1)traceNet(w.end,id);if(w.end===n&&w.start.netId===-1)traceNet(w.start,id);}); 
        }

        let c=0; nodes.forEach(n=>{if(n.netId===-1){traceNet(n,c);c++;}});
        let g=false; parts.filter(p=>['source','ac_source'].includes(p.type)).forEach(s=>{if(!g){const n=nets[s.nodes[0].netId]; if(n){n.fixed=true;n.voltage=0;g=true;}}});
        if(!g&&nets.length>0&&nets[0]){nets[0].fixed=true;nets[0].voltage=0;}
        
        for(let k=0;k<ITERATIONS;k++){
            nets.forEach(net=>{
                if(!net||net.fixed)return; let num=0,den=G_LEAK;
                net.nodes.forEach(node=>{
                    const p=node.parentPart; if(p.type==='joint')return;
                    const oNode=(p.nodes[0]===node)?p.nodes[1]:p.nodes[0]; const oNet=nets[oNode.netId]; if(!oNet)return;
                    let r=1e9, v_off=0;
                    if(['source','ac_source'].includes(p.type)){r=INTERNAL_R_SRC; v_off=(p.nodes[1]===node)?p.value:-p.value;}
                    else if(p.type==='switch')r=p.isOpen?R_SWITCH_OPEN:R_SWITCH_CLOSED;
                    else if(['resistor','voltmeter'].includes(p.type))r=p.value;
                    else if(['ammeter','galvanometer'].includes(p.type))r=INTERNAL_R_AMMETER;
                    else if(p.type==='capacitor'){
                        r=dt/(p.value*1e-6); 
                        // ★修正: コンパニオンモデルの電圧源の極性を修正
                        // V_off は「過去の電圧(state)」。
                        // ノード方程式において、相手側ノードの電圧に加算するオフセット。
                        // 極性を反転させました。
                        v_off=(p.nodes[1]===node)?-p.voltageState:p.voltageState;
                    }
                    else if(p.type==='inductor'){
                        r = p.value/dt;
                        const v_eq = r * p.current; 
                        if (p.nodes[1] === node) v_off = v_eq; else v_off = -v_eq;
                    }
                    const g=1.0/r; num+=(oNet.voltage+v_off)*g; den+=g;
                });
                if(den>0)net.voltage=num/den;
            });
        }
        nets.forEach(net=>{if(net)net.nodes.forEach(n=>n.voltage=net.voltage);});
        parts.forEach(p=>{
            if(p.type==='joint')return; const vd=p.getVoltageDiff();
            if(p.type==='capacitor'){const req=dt/(p.value*1e-6); p.current=(vd-p.voltageState)/req;}
            else if(p.type==='inductor'){
            }
            else if(p.type==='switch')p.current=vd/(p.isOpen?R_SWITCH_OPEN:R_SWITCH_CLOSED);
            else if(['source','ac_source'].includes(p.type))p.current=(p.value+vd)/INTERNAL_R_SRC;
            else p.current=vd/(p.type==='ammeter'?INTERNAL_R_AMMETER:p.value);
        });
    }

    function stepTime() {
        simTime+=dt; animationOffset+=dt;
        parts.forEach(p=>{if(p.type==='ac_source')p.value=p.amplitude*Math.sin(2*Math.PI*p.freq*simTime);});
        parts.forEach(p=>{
            const vd=p.getVoltageDiff();
            if(p.type==='capacitor')p.voltageState+=(p.current/(p.value*1e-6))*dt;
            else if(p.type==='inductor'){
                p.current+=(vd/p.value)*dt; 
                //p.current*=0.9995;
            }
        });
        if(selectedParts.length===1 && selectedParts[0].type!=='joint'){
            const p=selectedParts[0]; historyData.push({v:p.getVoltageDiff(), i:p.current, q:p.getCharge()});
            if(historyData.length>MAX_HISTORY)historyData.shift();
        }
    }

    function draw() {
        if(width===0||height===0)return; ctx.clearRect(0,0,width,height);
        
        ctx.strokeStyle="#27ae60"; ctx.lineWidth=2; ctx.beginPath();
        wires.forEach(w=>{ ctx.moveTo(w.start.x, w.start.y); ctx.lineTo(w.end.x, w.start.y); ctx.lineTo(w.end.x, w.end.y); });
        ctx.stroke();

        ctx.fillStyle="#27ae60";
        wires.forEach(w=>{ ctx.beginPath(); ctx.arc(w.start.x,w.start.y,3,0,2*Math.PI); ctx.fill(); ctx.beginPath(); ctx.arc(w.end.x,w.end.y,3,0,2*Math.PI); ctx.fill(); ctx.beginPath(); ctx.arc(w.end.x, w.start.y, 2, 0, 2*Math.PI); ctx.fill(); });

        if(currentTool==='wire'&&isDragging&&dragStartNode){
            ctx.strokeStyle="#2ecc71"; ctx.lineWidth=2; ctx.setLineDash([5,5]); ctx.beginPath();
            ctx.moveTo(dragStartNode.x, dragStartNode.y); const tx = mousePos.x, ty = mousePos.y; ctx.lineTo(tx, dragStartNode.y); ctx.lineTo(tx, ty); 
            ctx.stroke(); ctx.setLineDash([]);
            const gx = Math.round(mousePos.x/GRID_SIZE)*GRID_SIZE; const gy = Math.round(mousePos.y/GRID_SIZE)*GRID_SIZE;
            ctx.fillStyle="rgba(46, 204, 113, 0.5)"; ctx.beginPath(); ctx.arc(gx, gy, 6, 0, 2*Math.PI); ctx.fill();
        }
        if(currentTool==='select'&&isBoxSelecting){ ctx.fillStyle="rgba(52,152,219,0.2)"; ctx.strokeStyle="#3498db"; ctx.lineWidth=1; ctx.setLineDash([3,3]); ctx.fillRect(selectionBox.x,selectionBox.y,selectionBox.w,selectionBox.h); ctx.strokeRect(selectionBox.x,selectionBox.y,selectionBox.w,selectionBox.h); ctx.setLineDash([]); }
        parts.forEach(p=>p.draw(ctx));
        if(currentTool==='wire'&&hoverNode){ctx.beginPath();ctx.fillStyle="#e74c3c";ctx.arc(hoverNode.x,hoverNode.y,6,0,2*Math.PI);ctx.fill();}
    }

    function drawGraph() {
        if(selectedParts.length!==1 || selectedParts[0].type==='joint'){gCtx.clearRect(0,0,graphW,graphH); gCtx.fillStyle="#aaa"; gCtx.font="12px sans-serif"; gCtx.textAlign="center"; gCtx.fillText("素子を選択 (中継点以外)",graphW/2,graphH/2); return;}
        gCtx.clearRect(0,0,graphW,graphH); const p=selectedParts[0];
        const PT=20, PB=20, PL=5, PR=5, DH=graphH-PT-PB, CY=PT+DH/2;
        let mv=0.1; historyData.forEach(d=>{const a=Math.abs(d.v); if(a>mv)mv=a;}); mv*=1.1; const sv=(DH/2)/mv;
        let m2=1e-9; const isC=p.type==='capacitor', u2=isC?"C":"A";
        historyData.forEach(d=>{const v=isC?d.q:d.i, a=Math.abs(v); if(a>m2)m2=a;}); m2*=1.1; const s2=(DH/2)/m2;
        gCtx.strokeStyle="#eee"; gCtx.lineWidth=1; gCtx.setLineDash([5,5]); gCtx.beginPath(); gCtx.moveTo(0,CY);gCtx.lineTo(graphW,CY); gCtx.moveTo(0,PT);gCtx.lineTo(graphW,PT); gCtx.moveTo(0,graphH-PB);gCtx.lineTo(graphW,graphH-PB); gCtx.stroke(); gCtx.setLineDash([]);
        gCtx.strokeStyle="#ccc"; gCtx.beginPath(); gCtx.moveTo(0,CY);gCtx.lineTo(graphW,CY); gCtx.stroke();
        gCtx.font="11px sans-serif"; gCtx.textAlign="left"; gCtx.fillStyle="#2980b9"; gCtx.fillText("+"+formatValue(mv,"V",true),PL,PT-5); gCtx.fillText("-"+formatValue(mv,"V",true),PL,graphH-5);
        let cv=historyData.length>0?historyData[historyData.length-1].v:p.getVoltageDiff(); gCtx.font="bold 12px sans-serif"; gCtx.fillText("V: "+formatValue(cv,"V",false),PL+80,PT-5);
        gCtx.textAlign="right"; gCtx.fillStyle=isC?"#27ae60":"#e67e22"; gCtx.font="11px sans-serif"; gCtx.fillText("+"+formatValue(m2,u2,true),graphW-PR,PT-5); gCtx.fillText("-"+formatValue(m2,u2,true),graphW-PR,graphH-5);
        let c2=0; if(historyData.length>0)c2=isC?historyData[historyData.length-1].q:historyData[historyData.length-1].i; else c2=isC?p.getCharge():p.current;
        gCtx.font="bold 12px sans-serif"; gCtx.fillText((isC?"Q: ":"I: ")+formatValue(c2,u2,false),graphW-PR-80,PT-5);
        if(historyData.length>1){
            const plt=(fn,sc,cl)=>{gCtx.strokeStyle=cl; gCtx.lineWidth=2; gCtx.beginPath(); historyData.forEach((d,i)=>{const x=(i/(MAX_HISTORY-1))*graphW, y=CY-(fn(d)*sc); if(i===0)gCtx.moveTo(x,y); else gCtx.lineTo(x,y);}); gCtx.stroke();}
            plt(d=>d.v,sv,"rgba(41,128,185,0.7)"); if(isC)plt(d=>d.q,s2,"rgba(39,174,96,0.9)"); else plt(d=>d.i,s2,"rgba(230,126,34,0.9)");
        }
    }

    function loop() {
        if(document.getElementById('simulation-pane').classList.contains('active')) {
            solveCircuit(); if(isRunning) stepTime(); draw(); drawGraph();
            if(selectedParts.length===1) updateMeasurements();
        }
        requestAnimationFrame(loop);
    }
    resize(); resizeGraph(); loop();
</script>
</body>
</html>
